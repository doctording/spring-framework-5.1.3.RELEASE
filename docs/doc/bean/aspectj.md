# Aop 代理

* Spring AOP 属于运行时增强，而 AspectJ 是编译时增强
* Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)

附：动态字节码生成代理

```java
       编译                     ClassLoader加载                 实例
        
.java ------> .class(字节码)  -------------------> Class Obj ------------> Class Instance
```


|类别	| 机制 | 原理 | 	优点	| 缺点| 技术|
|:----:|:----:|:----:|:----:|:----:|:----:|
|静态AOP|静态织入|在编译期,切面直接以字节码的形式编译到目标字节码文件中	|对系统无性能影响	|灵活性不够	|AspectJ|
|动态AOP	|动态代理	|在运行期,目标类加载后，为接口动态生成代理类，将切面植入到代理类中	|相对于静态AOP更加灵活 |	切入的关注点需要实现接口。对系统有一点性能影响	|JDK dynamic proxy|
|动态字节码生成|	在运行期|-|目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中	没有接口也可以织入 |扩展类的实例方法为final时，则无法进行织入	|cglib|
|自定义类加载器|	在运行期|-|目标加载前，将切面逻辑加到目标字节码里	 |	可以对绝大部分类进行织入	代码中如果使用了其他类加载器，则这些类将不会被织入	| - |
|字节码转换|	在运行期|-|所有类加载器加载字节码前，前进行拦截	| 	可以对所有类进行织入	 | -|
