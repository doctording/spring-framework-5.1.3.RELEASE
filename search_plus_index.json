{"./":{"url":"./","title":"Introduction","keywords":"","body":"spring 源码实战阅读笔记 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-01 23:59:10 "},"doc/target.html":{"url":"doc/target.html","title":"1 前言","keywords":"","body":"学习目标 熟悉Spring原理 对各种Spring面试题能从容对答 借此熟悉各种设计模式，巩固各种Java基础知识 借此养成独立读英文文档,自己看源码并自主分析的能力 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-04 12:23:46 "},"doc/test/flow_path.html":{"url":"doc/test/flow_path.html","title":"2.1 ApplicationContext执行流程","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 测试代码执行流程 测试代码&xml 运行流程图 整个代码执行的流程图 测试代码执行流程 测试代码&xml code 见：spring-framework-5.1.3.RELEASE/spring-context/src/test/java/test/com/mb/BeanTest.java @Test public void testClassPathXmlApplicationContextBeanCosr() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-constructor.xml\"); User user = (User) applicationContext.getBean(\"user\"); Assert.assertTrue(user != null); Assert.assertTrue(user.getTestStr().equals(\"testStr\")); Assert.assertTrue(user.getId().equals(1)); Assert.assertTrue(user.getName().equals(\"tom\")); } spring-constructor.xml 运行流程图 整个代码执行的流程图 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-04 12:26:40 "},"doc/test/code_review.html":{"url":"doc/test/code_review.html","title":"2.2 执行流程源码走读","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 ClassPathXmlApplicationContext & getBean ClassPathXmlApplicationContext构造函数执行 设置Environment环境变量和configLocations AbstractApplicationContext的refresh方法 prepareRefresh()先跳过 BeanFactory构造 抽象类AbstractXmlApplicationContext的loadBeanDefinitions方法 prepareBeanFactory(beanFactory) postProcessBeanFactory(beanFactory的postProcessor) registerBeanPostProcessors((bean的postProcessor)) initMessageSource & initApplicationEventMulticaster(消息和广播初始化) registerListeners()（注册监听器） finishBeanFactoryInitialization(beanFactory)（实例化操作） 抽象类AbstractAutowireCapableBeanFactory的doCreateBean方法 抽象类AbstractAutowireCapableBeanFactory的createBeanInstance方法 本例使用了无参的构造器return instantiateBean(beanName, mbd); BeanUtils的instantiateClass(ConstructorT ctor, Object... args)方法 反射:ctor.newInstance(args) finishRefresh() User user = (User) applicationContext.getBean(\"user\"); ClassPathXmlApplicationContext & getBean ClassPathXmlApplicationContext构造函数执行 附ClassPathXmlApplicationContext类的UML 测试例子使用的构造函数 public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); // 设置`this.configLocations` setConfigLocations(configLocations); if (refresh) { // 这里refresh为true（重点方法） // 这里使用了父类`AbstractApplicationContext`的`refresh`方法 refresh(); } } 设置Environment环境变量和configLocations AbstractApplicationContext的refresh方法 refresh方法概述了Ioc容器的处理流程 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // 内部的 BeanFactory // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); // 先看try里面做了哪些事情(读别的源码也一样，先主后次) try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } prepareRefresh()先跳过 BeanFactory构造 构造生成ConfigurableListableBeanFactory类型的BeanFactory refresh方法中构造beanFactory具体是DefaultListableBeanFactory，调用了抽象类AbstractRefreshableApplicationContext的refreshBeanFactory方法 @Override protected final void refreshBeanFactory() throws BeansException { // 如果BeanFactory不为空，则清除BeanFactory里面的实例，并销毁BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // BeanFactory的实例工厂：DefaultListableBeanFactory DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); // 设置是否可以同名覆盖，循环依赖 customizeBeanFactory(beanFactory); // 解析比如xml文件，并把xml文件中的标签封装成BeanDefinition对象，加载到工厂中, 通常是通过代理读取器实现 // 比如 通过 XmlBeanDefinitionReader 读取 ClassPathXmlApplicationContext中传入的 configResources xml【模板设计】 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); } } 抽象类AbstractXmlApplicationContext的loadBeanDefinitions方法 BeanFactory实例工厂完成解析xml文件中的Bean并封装成BeanDefinition加载到工厂中 DefaultListableBeanFactory存储了BeanDefinition /** Map of bean definition objects, keyed by bean name. */ private final Map beanDefinitionMap = new ConcurrentHashMap<>(256); 附DefaultListableBeanFactoryUML（DefaultListableBeanFactory就是一个独立的Ioc容器） 有了beanFactory,要使用之，还要做各种工作，回到refresh方法 prepareBeanFactory(beanFactory) /** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */ protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 设置类加载器（要实例化bean,就需要类加载器） // Tell the internal bean factory to use the context's class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); // 设置EL表达式解析器（Bean初始化完成后填充属性时会用到） beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // 设置属性注册解析器PropertyEditor beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // 注册各种系统环境的bean组件（environment，systemProperties，systemEnvironment） // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } } postProcessBeanFactory(beanFactory的postProcessor) 在所有的BeanDefinition加载完成之后，bean实例化之前执行 /** * Modify the application context's internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for registering special * BeanPostProcessors etc in certain ApplicationContext implementations. * @param beanFactory the bean factory used by the application context */ protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { } // TODO 测试 invokeBeanFactoryPostProcessors(beanFactory) /** * Instantiate and invoke all registered BeanFactoryPostProcessor beans, * respecting explicit order if given. * Must be called before singleton instantiation. */ protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { // 1.getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值 // 2.invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } registerBeanPostProcessors((bean的postProcessor)) /** * Instantiate and invoke all registered BeanPostProcessor beans, * respecting explicit order if given. * Must be called before any instantiation of application beans. */ protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this); } initMessageSource & initApplicationEventMulticaster(消息和广播初始化) // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); 消息处理 & 事件监听 Initialize other special beans in specific context subclasses. onRefresh() /** * Template method which can be overridden to add context-specific refresh work. * Called on initialization of special beans, before instantiation of singletons. * This implementation is empty. * @throws BeansException in case of errors * @see #refresh() */ protected void onRefresh() throws BeansException { // For subclasses: do nothing by default. } registerListeners()（注册监听器） /** * Add beans that implement ApplicationListener as listeners. * Doesn't affect other listeners, which can be added without being beans. */ protected void registerListeners() { // 注册特殊的监听器 // Register statically specified listeners first. for (ApplicationListener listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // 取到所有监听器的名称，设置到上文初始化的广播器 // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); } // 如果存在早期应用事件，发布 // Publish early application events now that we finally have a multicaster... Set earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (earlyEventsToProcess != null) { for (ApplicationEvent earlyEvent : earlyEventsToProcess) { getApplicationEventMulticaster().multicastEvent(earlyEvent); } } } finishBeanFactoryInitialization(beanFactory)（实例化操作） 创建所有非懒加载的单例类（并invoke BeanPostProcessors） 抽象类AbstractAutowireCapableBeanFactory的doCreateBean方法 /** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */ protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { 抽象类AbstractAutowireCapableBeanFactory的createBeanInstance方法 /** * Create a new instance for the specified bean, using an appropriate instantiation strategy: * factory method, constructor autowiring, or simple instantiation. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a BeanWrapper for the new instance * @see #obtainFromSupplier * @see #instantiateUsingFactoryMethod * @see #autowireConstructor * @see #instantiateBean */ protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { 本例使用了无参的构造器return instantiateBean(beanName, mbd); /** * Instantiate the given bean using its default constructor. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @return a BeanWrapper for the new instance */ protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { try { Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) { beanInstance = AccessController.doPrivileged((PrivilegedAction) () -> getInstantiationStrategy().instantiate(mbd, beanName, parent), getAccessControlContext()); } else { beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); } BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; } catch (Throwable ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex); } } BeanUtils的instantiateClass(Constructor ctor, Object... args)方法 /** * Convenience method to instantiate a class using the given constructor. * Note that this method tries to set the constructor accessible if given a * non-accessible (that is, non-public) constructor, and supports Kotlin classes * with optional parameters and default values. * @param ctor the constructor to instantiate * @param args the constructor arguments to apply (use {@code null} for an unspecified * parameter if needed for Kotlin classes with optional parameters and default values) * @return the new instance * @throws BeanInstantiationException if the bean cannot be instantiated * @see Constructor#newInstance */ public static T instantiateClass(Constructor ctor, Object... args) throws BeanInstantiationException { Assert.notNull(ctor, \"Constructor must not be null\"); try { ReflectionUtils.makeAccessible(ctor); return (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ? KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args)); } catch (InstantiationException ex) { throw new BeanInstantiationException(ctor, \"Is it an abstract class?\", ex); } catch (IllegalAccessException ex) { throw new BeanInstantiationException(ctor, \"Is the constructor accessible?\", ex); } catch (IllegalArgumentException ex) { throw new BeanInstantiationException(ctor, \"Illegal arguments for constructor\", ex); } catch (InvocationTargetException ex) { throw new BeanInstantiationException(ctor, \"Constructor threw exception\", ex.getTargetException()); } } 反射:ctor.newInstance(args) 实例通过反射new出来了；反射相关知识参考：Java反射机制 finishRefresh() /** * Finish the refresh of this context, invoking the LifecycleProcessor's * onRefresh() method and publishing the * {@link org.springframework.context.event.ContextRefreshedEvent}. */ protected void finishRefresh() { // Clear context-level resource caches (such as ASM metadata from scanning). clearResourceCaches(); // Initialize lifecycle processor for this context. initLifecycleProcessor(); // Propagate refresh to lifecycle processor first. getLifecycleProcessor().onRefresh(); // Publish the final event. publishEvent(new ContextRefreshedEvent(this)); // Participate in LiveBeansView MBean, if active. LiveBeansView.registerApplicationContext(this); } User user = (User) applicationContext.getBean(\"user\"); AbstractBeanFactory的doGetBean方法 protected T doGetBean(final String name, @Nullable final Class requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-19 22:51:08 "},"doc/test/bean_constructor.html":{"url":"doc/test/bean_constructor.html","title":"2.3 bean & constructor-arg","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 bean & constructor-arg 测试代码&xml 流程关键点说明 构造BeanFactory(loadBeanDefinitions(beanFactory)会加载好构造参数) doGetBean方法读取BeanDefinition会读取到构造参数 在构造的时候会根据beanDefinition选择构造方法 最后使用BeanUtils实例化的时候会带上参数 bean & constructor-arg 主要说下跟默认构造函数构造bean的区别之处 测试代码&xml code 见：spring-framework-5.1.3.RELEASE/spring-context/src/test/java/test/com/mb/BeanTest.java @Test public void testClassPathXmlApplicationContextBean() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); User user = (User) applicationContext.getBean(\"user\"); Assert.assertTrue(user != null); Assert.assertTrue(user.getTestStr().equals(\"testStr\")); } spring.xml 流程关键点说明 构造BeanFactory(loadBeanDefinitions(beanFactory)会加载好构造参数) doGetBean方法读取BeanDefinition会读取到构造参数 在构造的时候会根据beanDefinition选择构造方法 最后使用BeanUtils实例化的时候会带上参数 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-20 10:00:06 "},"doc/bean/ioc_bean.html":{"url":"doc/bean/ioc_bean.html","title":"2.4 附:Ioc & Bean概念","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Ioc 容器 & Bean Spring处理流程简图 Ioc Container Bean Ioc 容器 & Bean Spring处理流程简图 附：spring docs Ioc Container The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects. ApplicationContext这个接口就代表IoC容器，它负责实例化、配置和组装bean。容器通过读取配置文件的元数据来获取要实例化、配置和组装哪些对象的指令。配置文件支持xml,Java注解和纯Java代码。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。 Bean In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container. 在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是一个由Spring IoC容器实例化、组装和管理的对象。 Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata: 在容器内部，这些bean定义表示为BeanDefinition对象，包含着以下元数据： A package-qualified class name: typically, the actual implementation class of the bean being defined.（全限定类名） Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).（Bean的行为配置元素，作用域，生命周期回调等） References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.（对该bean执行其工作所需的其它bean的引用。） Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.（在创建bean对象时的其他配置，如连接池的最大数量） Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 13:18:38 "},"doc/bean/BeanFactory.html":{"url":"doc/bean/BeanFactory.html","title":"2.5 附:BeanFactory接口","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 BeanFactory 定义和类图 BeanFactory 定义和类图 spring docs of BeanFactory The root interface for accessing a Spring bean container. 访问Spring容器的最顶层的interface This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. \"request\" and \"session\" scopes in a web environment). BeanFactory的实现类即具体的容器，拥有一系列bean的定义，并实现这些基础方法，能返回bean的对象实例 The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of \"Expert One-on-One J2EE Design and Development\" for a discussion of the benefits of this approach. BeanFactory是应用程序组件的注册器，统一管理 Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection). BeanFactory负责加载bean,并能返回Java对象实例，并最好能支持Bean之间的引用关系 Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. BeanFactory要尽可能的实现Bean的生命周期接口 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "},"doc/bean/aop.html":{"url":"doc/bean/aop.html","title":"3.1 AOP的理解","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 AOP Spring AOP 各种概念 AOP Spring AOP 各种概念 spring aop reference Aspect Join point(连接点) A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution. 通常就是一个执行的方法 Advice(增强器) Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point. 在特定的join point增强 1. Before 2. After 3. AfterReturn 4. AfterThrowing 5. Around Pointcut(切点) A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default. 简单认为是：某些特定的join point的集合 Introduction Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.) Target object An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object. 增强对象(新对象，代理对象)，被增强的那个原始对象就是Target object AOP proxy An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy. Weaving linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime. Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-04 12:29:45 "},"doc/bean/dependency.html":{"url":"doc/bean/dependency.html","title":"3.2 Spring循环依赖具体执行流程","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 循环依赖 什么是依赖？ Spring中循环依赖场景 singleton bean 属性循环依赖无问题 单例Bean循环依赖理解图 单例的三级缓存获取:getSingleton方法 三级缓存涉及要点说明 singletonObjectsmap结构（一级缓存） earlySingletonObjectsmap结构(二级缓存) singletonsCurrentlyInCreationSet集合(创建中Bean集合) singletonFactoriesmap结构(三级缓存) AbstractBeanFactory类的doGetBean方法 DefaultSingletonBeanRegistry类的getSingleton方法逻辑 AbstractAutowireCapableBeanFactory类的doCreateBean方法 Debug过程中的要点与截图 为什么是三级缓存？ scope bean 循环依赖有问题？ 测试代码 异常栈 循环依赖 什么是依赖？ eg1 A -> B B -> A eg2 A -> B -> C -> A Spring中循环依赖场景 构造器的循环依赖(spring无法解决) field属性的循环依赖(spring能解决单例bean的属性循环依赖) singleton bean 属性循环依赖无问题 单例Bean循环依赖理解图 单例的三级缓存获取:getSingleton方法 /** * Return the (raw) singleton object registered under the given name. * Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or {@code null} if none found */ @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null && allowEarlyReference) { ObjectFactory singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return singletonObject; } 三级缓存涉及要点说明 singletonObjectsmap结构（一级缓存） /** Cache of singleton objects: bean name to bean instance. */ private final Map singletonObjects = new ConcurrentHashMap<>(256); singletonObjects存储的实例是已经实例化的单例，并且初始化完成的(一般称为：单例缓存池) earlySingletonObjectsmap结构(二级缓存) /** Cache of early singleton objects: bean name to bean instance. */ private final Map earlySingletonObjects = new HashMap<>(16); 从singletonObjects取不到，且该Bean在创建过程中，则从earlySingletonObjects获取 singletonsCurrentlyInCreationSet集合(创建中Bean集合) isSingletonCurrentlyInCreation()方法判断当前单例Bean是否正在创建中（在创建中的Bean是没有初始化完全的） /** * Return whether the specified singleton bean is currently in creation * (within the entire factory). * @param beanName the name of the bean */ public boolean isSingletonCurrentlyInCreation(String beanName) { return this.singletonsCurrentlyInCreation.contains(beanName); } 将创建中的bean加入到singletonsCurrentlyInCreation集合中 singletonFactoriesmap结构(三级缓存) /** Cache of singleton factories: bean name to ObjectFactory. */ private final Map> singletonFactories = new HashMap<>(16); 从earlySingletonObjects取不到则从singletonFactories取，存储的是 AbstractBeanFactory类的doGetBean方法 // Create bean instance. if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -> { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } 也是getSingleton方法，有个lambda表达式的createBean方法 DefaultSingletonBeanRegistry类的getSingleton方法逻辑 /** * Return the (raw) singleton object registered under the given name, * creating and registering a new one if none registered yet. * @param beanName the name of the bean * @param singletonFactory the ObjectFactory to lazily create the singleton * with, if necessary * @return the registered singleton object */ public Object getSingleton(String beanName, ObjectFactory singletonFactory) { Assert.notNull(beanName, \"Bean name must not be null\"); synchronized (this.singletonObjects) { // 1. 仍然是先判断是否在一级缓存中 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, \"Singleton bean creation not allowed while singletons of this factory are in destruction \" + \"(Do not request a bean from a BeanFactory in a destroy method implementation!)\"); } if (logger.isDebugEnabled()) { logger.debug(\"Creating shared instance of singleton bean '\" + beanName + \"'\"); } // 2. 创建前加入到`singletonsCurrentlyInCreation`集合中, 表示正在创建 beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) { this.suppressedExceptions = new LinkedHashSet<>(); } try { // 3. 执行lambda表达式的创建逻辑获取到单例bean，即执行`doCreateBean` singletonObject = singletonFactory.getObject(); newSingleton = true; } catch (IllegalStateException ex) { // Has the singleton object implicitly appeared in the meantime -> // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { throw ex; } } catch (BeanCreationException ex) { if (recordSuppressedExceptions) { for (Exception suppressedException : this.suppressedExceptions) { ex.addRelatedCause(suppressedException); } } throw ex; } finally { if (recordSuppressedExceptions) { this.suppressedExceptions = null; } // 4. 创建完成后从`singletonsCurrentlyInCreation`集合中移除, 非创建状态 afterSingletonCreation(beanName); } if (newSingleton) { // 5. 加入到一级缓存中，且从二级，三级缓存移除 addSingleton(beanName, singletonObject); } } // 6. 返回最终完整实例化的bean return singletonObject; } } AbstractAutowireCapableBeanFactory类的doCreateBean方法 /** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */ protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 1. factoryBeanInstanceCache 没有则需要主动创建 instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = instanceWrapper.getWrappedInstance(); Class beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); } mbd.postProcessed = true; } } // 加入到三级缓存:即添加,此为提前暴露早期对象 // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); } addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. Object exposedObject = bean; try { // 2. 填充bean的属性:即这里要完成bean依赖处理 populateBean(beanName, mbd, instanceWrapper); // 3. bean的initialize,beanPostProcessor等 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } if (earlySingletonExposure) { // 获取到AOP之后的代理对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { // 如果提前暴露的对象和经过了完整的生命周期后的对象相等，那么把代理对象赋值给`exposedObject` if (exposedObject == bean) { exposedObject = earlySingletonReference; } // 如果提前暴露的对象和经过了完整的生命周期后的对象不相等 // allowRawInjectionDespiteWrapping 表示在循环依赖时 else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set actualDependentBeans = new LinkedHashSet<>(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); } } } } // Register bean as disposable. try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); } return exposedObject; } Debug过程中的要点与截图 populateBean(\"b\", mbd, instanceWrapper)的时候，发现依赖了A，要去getBean(\"a\"),执行到getSingleton方法，此时从三级缓存中取到 从三级缓存取到A之后,执行了lambda(bean A)的逻辑，并将bean A加入二级缓存，并返回 由于从三级缓存拿到了提交曝光的A，B就正常的完成A依赖的设置，顺利完成populateBean方法 B实例化全部完成后，加入到单例缓存池(一级缓存)中 由于B实例化的完成，A的实例化也就能正常完成，并在最后也加入到单例缓存池(一级缓存)中 为什么是三级缓存？ Bean生命周期 A class --- BeanDefinition new A(); // 原始对象 populateBean（依赖注入）--> 单例池中找B --> 找不到 --> 创建B initializeBean BeanPostProcessor 完成并添加到单例池中 Bean生命周期 B class --- BeanDefinition new B(); // 原始对象 populateBean（依赖注入）--> 单例池中找A --> 找不到 --> 三级缓存中能找到 --> lambda(A) --> 提前得到代理A initializeBean BeanPostProcessor 完成并添加到单例池中 按照如上，如果只有 一级缓存 和 三级缓存，能够解决A,B依赖问题，接着又来了个C(且依赖A)；如果按照上面B的逻辑，那么可以发现lambda(A)会再次被执行，这可能导致B，C执行后获取的代理A不一致 Bean生命周期 C class --- BeanDefinition new C(); // 原始对象 populateBean（依赖注入）--> 单例池中找A --> 找不到 --> 三级缓存中能找到 --> lambda(A) --> 提前得到代理A initializeBean BeanPostProcessor 完成并添加到单例池中 所以再来一个缓存, 将代理对象也缓存起来，所以最后是三级缓存 单例池 map map 参考：bilibili 子路老师 scope bean 循环依赖有问题？ 测试代码 @Test public void testDependencySpringPrototype() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-dependency-prototype.xml\"); A a = (A) applicationContext.getBean(\"a\"); B b = (B) applicationContext.getBean(\"b\"); Assert.assertTrue(a != null); Assert.assertTrue(b != null); } spring-dependency-prototype.xml 异常栈 constructor A() constructor B() org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'a' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'b' while setting bean property 'b'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'b' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'a' while setting bean property 'a'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:378) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:110) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1648) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1400) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:575) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1094) at test.com.mb.DependencyTest.testDependencySpringPrototype(DependencyTest.java:44) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'b' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'a' while setting bean property 'a'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:378) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:110) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1648) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1400) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:575) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:367) ... 31 more Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:264) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:367) ... 39 more Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-01 23:50:19 "},"doc/bean/bean_life.html":{"url":"doc/bean/bean_life.html","title":"3.3 Bean生命周期","keywords":"","body":"bean的生命周期？ 以如下测试代码为例 @Test public void testClassPathXmlApplicationContextBean() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-full-life.xml\"); System.out.println(\"----------------applicationContext\"); FullBean fullBean = (FullBean)applicationContext.getBean(\"fullBean\"); System.out.println(\"fullBean.getName:\" + fullBean.getName()); ((ClassPathXmlApplicationContext) applicationContext).close(); } 其中单例fullBean依赖了单例fullBeanB且配置了相关初始化，销毁方法，和BeanPostProcessor fullBean生命周期 ClassPathXmlApplicationContext doGetBean(InstantiationAwareBeanPostProcessor doGetBean(BeanPostProcessor doGetBean(fullBean dependsOn createBean resolveBeforeInstantiation applyBeanPostProcessorsBeforeInstantiation（应用所有的InstantiationAwareBeanPostProcessor） postProcessBeforeInstantiation doCreateBean createBeanInstance(默认构造方法，反射创建一个对象) populateBean(设置属性，其中依赖Bean 走 dochteren逻辑) InstantiationAwareBeanPostProcessor：postProcessAfterInstantiation applyPropertyValues(beanName, mbd, bw, pvs); initializeBean applyBeanPostProcessorsBeforeInitialization（应用所有的BeanPostProcessor） postProcessBeforeInitialization invokeInitMethods InitializingBean(afterPropertiesSet) InitMethod 加入单例池 fullBean.getName ( bean的使用) ((ClassPathXmlApplicationContext) applicationContext).close() doClose Publish shutdown event. lifecycleProcessor.onClose(); destroyBeans DisposableBean destroy-method closeBeanFactory onClose() this.active.set(false); Runtime.getRuntime().removeShutdownHook(this.shutdownHook); Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-05 23:54:27 "},"doc/bean/bean_fatory_bean.html":{"url":"doc/bean/bean_fatory_bean.html","title":"4.1 BeanFactory & FactoryBean","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 BeanFactory & FactoryBean 的区别 FactoryBean 官方文档阅读 FactoryBean 实践 BeanFactory & FactoryBean 的区别 Customizing Instantiation Logic with a FactoryBean FactoryBean 官方文档阅读 功能：使用FactoryBean定制bean的实例化逻辑 The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex initialization inside that class, and then plug your custom FactoryBean into the container. The FactoryBean interface provides three methods: Object getObject(): Returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes. boolean isSingleton(): Returns true if this FactoryBean returns singletons or false otherwise. Class getObjectType(): Returns the object type returned by the getObject() method or null if the type is not known in advance. FactoryBean 实践 实现一个FactoryBean import org.springframework.beans.factory.FactoryBean; /** * @Author mubi * @Date 2020/7/4 13:01 */ public class MyGoFactoryBean implements FactoryBean { private String type; private Go getDefaultGo(){ return new Go() { @Override public void out() { System.out.println(\"just go on foot\"); } }; } public String getType() { return type; } public void setType(String type) { this.type = type; } @Override public Go getObject(){ if (type == null) { return getDefaultGo(); } if (type.equalsIgnoreCase(GoEnum.BIKE.getType())) { return new BikeGo(); } if (type.equalsIgnoreCase(GoEnum.CAR.getType())) { return new CarGo(); } return getDefaultGo(); } @Override public Class getObjectType() { return Go.class ; } @Override public boolean isSingleton() { return false; } } xml 测试 @Test public void testDependencySpring() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-factory-bean.xml\"); Go go = (Go) applicationContext.getBean(\"go\"); go.out(); } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-04 13:42:20 "},"doc/bean/design.html":{"url":"doc/bean/design.html","title":"4.2 Spring中的设计模式","keywords":"","body":"Spring中用到了哪些设计模式？ Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-22 10:03:58 "},"doc/other/words.html":{"url":"doc/other/words.html","title":"5.1 单词","keywords":"","body":"单词 assemble v. 聚集; 集合; 收集; 装配; 组装; boilerplate n. (可供模仿的) 样板文件，文件范例; circular adj. 圆形的; 环形的; 圆的; 环行的; 绕圈的; 循环论证的(以一种观点证明另一观点，接着再用后一种观点反过来去证明前一观点); n. (同时送达很多人的)印刷信函(或通知、广告) ; customize vt. 定做，定制，按客户具体要求制造； convey v. 表达，传递(思想、感情等); 传送; 运送; 输送; explicit adj. 清楚明白的; 易于理解的; (说话) 清晰的，明确的; 直言的; 坦率的; 直截了当的; 不隐晦的; 不含糊的; instantiate v. 例示；用具体例子说明; instantiation n. 实例化；[计] 例示 interdependency n. 互相依赖；相关性; nested v. 筑巢; 巢居; 嵌套(信息); plug n. 插头；塞子；栓； vi. 塞住；用插头将与电源接通； vt. 插入；塞住；接插头 pluggability 可插性 scenario n. 设想; 方案; 预测; (电影或戏剧的) 剧情梗概; unresolvable 不能解决的 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-04 12:44:19 "}}