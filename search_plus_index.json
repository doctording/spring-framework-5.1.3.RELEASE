{"./":{"url":"./","title":"Introduction","keywords":"","body":"spring 源码实战阅读笔记 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-01 23:59:10 "},"doc/target.html":{"url":"doc/target.html","title":"1 前言","keywords":"","body":"学习目标 熟悉Spring原理 对各种Spring各种题能从容对答 借此熟悉各种设计模式，巩固各种Java基础知识 借此养成独立读英文文档,自己看源码并自主分析的能力 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-18 12:38:57 "},"doc/test/flow_path.html":{"url":"doc/test/flow_path.html","title":"2.1 ApplicationContext执行流程","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 测试代码执行流程 测试代码&xml 运行流程图 整个代码执行的流程图 测试代码执行流程 测试代码&xml code 见：spring-framework-5.1.3.RELEASE/spring-context/src/test/java/test/com/mb/BeanTest.java @Test public void testClassPathXmlApplicationContextBeanCosr() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-constructor.xml\"); User user = (User) applicationContext.getBean(\"user\"); Assert.assertTrue(user != null); Assert.assertTrue(user.getTestStr().equals(\"testStr\")); Assert.assertTrue(user.getId().equals(1)); Assert.assertTrue(user.getName().equals(\"tom\")); } spring-constructor.xml 运行流程图 整个代码执行的流程图 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-04 12:26:40 "},"doc/test/code_review.html":{"url":"doc/test/code_review.html","title":"2.2 执行流程源码走读","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 ClassPathXmlApplicationContext & getBean ClassPathXmlApplicationContext构造函数执行 设置Environment环境变量和configLocations AbstractApplicationContext的refresh方法 prepareRefresh()先跳过 BeanFactory构造 抽象类AbstractXmlApplicationContext的loadBeanDefinitions方法 prepareBeanFactory(beanFactory) postProcessBeanFactory(beanFactory的postProcessor) registerBeanPostProcessors((bean的postProcessor)) initMessageSource & initApplicationEventMulticaster(消息和广播初始化) registerListeners()（注册监听器） finishBeanFactoryInitialization(beanFactory)（实例化操作） 抽象类AbstractAutowireCapableBeanFactory的doCreateBean方法 抽象类AbstractAutowireCapableBeanFactory的createBeanInstance方法 本例使用了无参的构造器return instantiateBean(beanName, mbd); BeanUtils的instantiateClass(ConstructorT ctor, Object... args)方法 反射:ctor.newInstance(args) finishRefresh() User user = (User) applicationContext.getBean(\"user\"); ClassPathXmlApplicationContext & getBean ClassPathXmlApplicationContext构造函数执行 附ClassPathXmlApplicationContext类的UML 测试例子使用的构造函数 public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); // 设置`this.configLocations` setConfigLocations(configLocations); if (refresh) { // 这里refresh为true（重点方法） // 这里使用了父类`AbstractApplicationContext`的`refresh`方法 refresh(); } } 设置Environment环境变量和configLocations AbstractApplicationContext的refresh方法 refresh方法概述了Ioc容器的处理流程 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // 内部的 BeanFactory // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); // 先看try里面做了哪些事情(读别的源码也一样，先主后次) try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } prepareRefresh()先跳过 BeanFactory构造 构造生成ConfigurableListableBeanFactory类型的BeanFactory refresh方法中构造beanFactory具体是DefaultListableBeanFactory，调用了抽象类AbstractRefreshableApplicationContext的refreshBeanFactory方法 @Override protected final void refreshBeanFactory() throws BeansException { // 如果BeanFactory不为空，则清除BeanFactory里面的实例，并销毁BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // BeanFactory的实例工厂：DefaultListableBeanFactory DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); // 设置是否可以同名覆盖，循环依赖 customizeBeanFactory(beanFactory); // 解析比如xml文件，并把xml文件中的标签封装成BeanDefinition对象，加载到工厂中, 通常是通过代理读取器实现 // 比如 通过 XmlBeanDefinitionReader 读取 ClassPathXmlApplicationContext中传入的 configResources xml【模板设计】 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); } } 抽象类AbstractXmlApplicationContext的loadBeanDefinitions方法 BeanFactory实例工厂完成解析xml文件中的Bean并封装成BeanDefinition加载到工厂中 DefaultListableBeanFactory存储了BeanDefinition /** Map of bean definition objects, keyed by bean name. */ private final Map beanDefinitionMap = new ConcurrentHashMap<>(256); 附DefaultListableBeanFactoryUML（DefaultListableBeanFactory就是一个独立的Ioc容器） 有了beanFactory,要使用之，还要做各种工作，回到refresh方法 prepareBeanFactory(beanFactory) /** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */ protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 设置类加载器（要实例化bean,就需要类加载器） // Tell the internal bean factory to use the context's class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); // 设置EL表达式解析器（Bean初始化完成后填充属性时会用到） beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // 设置属性注册解析器PropertyEditor beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // 注册各种系统环境的bean组件（environment，systemProperties，systemEnvironment） // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } } postProcessBeanFactory(beanFactory的postProcessor) 在所有的BeanDefinition加载完成之后，bean实例化之前执行 /** * Modify the application context's internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for registering special * BeanPostProcessors etc in certain ApplicationContext implementations. * @param beanFactory the bean factory used by the application context */ protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { } // TODO 测试 invokeBeanFactoryPostProcessors(beanFactory) /** * Instantiate and invoke all registered BeanFactoryPostProcessor beans, * respecting explicit order if given. * Must be called before singleton instantiation. */ protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { // 1.getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值 // 2.invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } registerBeanPostProcessors((bean的postProcessor)) /** * Instantiate and invoke all registered BeanPostProcessor beans, * respecting explicit order if given. * Must be called before any instantiation of application beans. */ protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this); } initMessageSource & initApplicationEventMulticaster(消息和广播初始化) // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); 消息处理 & 事件监听 Initialize other special beans in specific context subclasses. onRefresh() /** * Template method which can be overridden to add context-specific refresh work. * Called on initialization of special beans, before instantiation of singletons. * This implementation is empty. * @throws BeansException in case of errors * @see #refresh() */ protected void onRefresh() throws BeansException { // For subclasses: do nothing by default. } registerListeners()（注册监听器） /** * Add beans that implement ApplicationListener as listeners. * Doesn't affect other listeners, which can be added without being beans. */ protected void registerListeners() { // 注册特殊的监听器 // Register statically specified listeners first. for (ApplicationListener listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // 取到所有监听器的名称，设置到上文初始化的广播器 // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); } // 如果存在早期应用事件，发布 // Publish early application events now that we finally have a multicaster... Set earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (earlyEventsToProcess != null) { for (ApplicationEvent earlyEvent : earlyEventsToProcess) { getApplicationEventMulticaster().multicastEvent(earlyEvent); } } } finishBeanFactoryInitialization(beanFactory)（实例化操作） 创建所有非懒加载的单例类（并invoke BeanPostProcessors） 抽象类AbstractAutowireCapableBeanFactory的doCreateBean方法 /** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */ protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { 抽象类AbstractAutowireCapableBeanFactory的createBeanInstance方法 /** * Create a new instance for the specified bean, using an appropriate instantiation strategy: * factory method, constructor autowiring, or simple instantiation. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a BeanWrapper for the new instance * @see #obtainFromSupplier * @see #instantiateUsingFactoryMethod * @see #autowireConstructor * @see #instantiateBean */ protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { 本例使用了无参的构造器return instantiateBean(beanName, mbd); /** * Instantiate the given bean using its default constructor. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @return a BeanWrapper for the new instance */ protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { try { Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) { beanInstance = AccessController.doPrivileged((PrivilegedAction) () -> getInstantiationStrategy().instantiate(mbd, beanName, parent), getAccessControlContext()); } else { beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); } BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; } catch (Throwable ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex); } } BeanUtils的instantiateClass(Constructor ctor, Object... args)方法 /** * Convenience method to instantiate a class using the given constructor. * Note that this method tries to set the constructor accessible if given a * non-accessible (that is, non-public) constructor, and supports Kotlin classes * with optional parameters and default values. * @param ctor the constructor to instantiate * @param args the constructor arguments to apply (use {@code null} for an unspecified * parameter if needed for Kotlin classes with optional parameters and default values) * @return the new instance * @throws BeanInstantiationException if the bean cannot be instantiated * @see Constructor#newInstance */ public static T instantiateClass(Constructor ctor, Object... args) throws BeanInstantiationException { Assert.notNull(ctor, \"Constructor must not be null\"); try { ReflectionUtils.makeAccessible(ctor); return (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ? KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args)); } catch (InstantiationException ex) { throw new BeanInstantiationException(ctor, \"Is it an abstract class?\", ex); } catch (IllegalAccessException ex) { throw new BeanInstantiationException(ctor, \"Is the constructor accessible?\", ex); } catch (IllegalArgumentException ex) { throw new BeanInstantiationException(ctor, \"Illegal arguments for constructor\", ex); } catch (InvocationTargetException ex) { throw new BeanInstantiationException(ctor, \"Constructor threw exception\", ex.getTargetException()); } } 反射:ctor.newInstance(args) 实例通过反射new出来了；反射相关知识参考：Java反射机制 finishRefresh() /** * Finish the refresh of this context, invoking the LifecycleProcessor's * onRefresh() method and publishing the * {@link org.springframework.context.event.ContextRefreshedEvent}. */ protected void finishRefresh() { // Clear context-level resource caches (such as ASM metadata from scanning). clearResourceCaches(); // Initialize lifecycle processor for this context. initLifecycleProcessor(); // Propagate refresh to lifecycle processor first. getLifecycleProcessor().onRefresh(); // Publish the final event. publishEvent(new ContextRefreshedEvent(this)); // Participate in LiveBeansView MBean, if active. LiveBeansView.registerApplicationContext(this); } User user = (User) applicationContext.getBean(\"user\"); AbstractBeanFactory的doGetBean方法 protected T doGetBean(final String name, @Nullable final Class requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-19 22:51:08 "},"doc/test/bean_constructor.html":{"url":"doc/test/bean_constructor.html","title":"2.3 bean & constructor-arg测试","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 bean & constructor-arg 测试代码&xml 流程关键点说明 构造BeanFactory(loadBeanDefinitions(beanFactory)会加载好构造参数) doGetBean方法读取BeanDefinition会读取到构造参数 在构造的时候会根据beanDefinition选择构造方法 最后使用BeanUtils实例化的时候会带上参数 bean & constructor-arg 主要说下跟默认构造函数构造bean的区别之处 测试代码&xml code 见：spring-framework-5.1.3.RELEASE/spring-context/src/test/java/test/com/mb/BeanTest.java @Test public void testClassPathXmlApplicationContextBean() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); User user = (User) applicationContext.getBean(\"user\"); Assert.assertTrue(user != null); Assert.assertTrue(user.getTestStr().equals(\"testStr\")); } spring.xml 流程关键点说明 构造BeanFactory(loadBeanDefinitions(beanFactory)会加载好构造参数) doGetBean方法读取BeanDefinition会读取到构造参数 在构造的时候会根据beanDefinition选择构造方法 最后使用BeanUtils实例化的时候会带上参数 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-20 10:00:06 "},"doc/bean/ioc_bean.html":{"url":"doc/bean/ioc_bean.html","title":"3.1 Ioc & Bean概念","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Ioc 容器 & Bean Spring处理流程简图 Ioc(Inversion of Control) Container Bean BeanDefinition Dependency Injection Ioc 容器 & Bean Spring处理流程简图 附：spring docs Ioc(Inversion of Control) Container The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects. ApplicationContext这个接口就代表IoC容器，它负责实例化、配置和组装bean。容器通过读取配置文件的元数据来获取要实例化、配置和组装哪些对象的指令。配置文件支持xml,Java注解和纯Java代码。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。 Bean In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container. 在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是一个由Spring IoC容器实例化、组装和管理的对象。 Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata: 在容器内部，这些bean定义表示为BeanDefinition对象，包含着以下元数据： A package-qualified class name: typically, the actual implementation class of the bean being defined.（全限定类名） Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).（Bean的行为配置元素，作用域，生命周期回调等） References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.（对该bean执行其工作所需的其它bean的引用。） Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.（在创建bean对象时的其他配置，如连接池的最大数量） BeanDefinition Class Name Scope Constructor arguments Properties Autowiring mode Lazy initialization mode Initialization method Destruction method Dependency Injection Constructor-based Dependency Injection Setter-based Dependency Injection Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-06 13:14:24 "},"doc/bean/BeanFactory.html":{"url":"doc/bean/BeanFactory.html","title":"3.1.1 BeanFactory接口","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 BeanFactory 定义和类图 BeanFactory 定义和类图 spring docs of BeanFactory The root interface for accessing a Spring bean container. 访问Spring容器的最顶层的interface This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. \"request\" and \"session\" scopes in a web environment). BeanFactory的实现类即具体的容器，拥有一系列bean的定义，并实现这些基础方法，能返回bean的对象实例 The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of \"Expert One-on-One J2EE Design and Development\" for a discussion of the benefits of this approach. BeanFactory是应用程序组件的注册器，统一管理 Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection). BeanFactory负责加载bean,并能返回Java对象实例，并最好能支持Bean之间的引用关系 Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. BeanFactory要尽可能的实现Bean的生命周期接口 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "},"doc/bean/dependency.html":{"url":"doc/bean/dependency.html","title":"3.2 Spring循环依赖具体执行流程","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 循环依赖 什么是依赖？ Spring中循环依赖场景 singleton bean 属性循环依赖无问题 单例Bean循环依赖理解图 单例的三级缓存获取:getSingleton方法 三级缓存涉及要点说明 singletonObjectsmap结构（一级缓存） earlySingletonObjectsmap结构(二级缓存) singletonsCurrentlyInCreationSet集合(创建中Bean集合) singletonFactoriesmap结构(三级缓存) AbstractBeanFactory类的doGetBean方法 DefaultSingletonBeanRegistry类的getSingleton方法逻辑 AbstractAutowireCapableBeanFactory类的doCreateBean方法 Debug过程中的要点与截图 为什么是三级缓存？ scope bean 循环依赖有问题？ 测试代码 异常栈 循环依赖 什么是依赖？ eg1 A -> B B -> A eg2 A -> B -> C -> A Spring中循环依赖场景 构造器的循环依赖(spring无法解决) field属性的循环依赖(spring能解决单例bean的属性循环依赖) singleton bean 属性循环依赖无问题 单例Bean循环依赖理解图 单例的三级缓存获取:getSingleton方法 /** * Return the (raw) singleton object registered under the given name. * Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or {@code null} if none found */ @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null && allowEarlyReference) { ObjectFactory singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return singletonObject; } 三级缓存涉及要点说明 singletonObjectsmap结构（一级缓存） /** Cache of singleton objects: bean name to bean instance. */ private final Map singletonObjects = new ConcurrentHashMap<>(256); singletonObjects存储的实例是已经实例化的单例，并且初始化完成的(一般称为：单例缓存池) earlySingletonObjectsmap结构(二级缓存) /** Cache of early singleton objects: bean name to bean instance. */ private final Map earlySingletonObjects = new HashMap<>(16); 从singletonObjects取不到，且该Bean在创建过程中，则从earlySingletonObjects获取 singletonsCurrentlyInCreationSet集合(创建中Bean集合) isSingletonCurrentlyInCreation()方法判断当前单例Bean是否正在创建中（在创建中的Bean是没有初始化完全的） /** * Return whether the specified singleton bean is currently in creation * (within the entire factory). * @param beanName the name of the bean */ public boolean isSingletonCurrentlyInCreation(String beanName) { return this.singletonsCurrentlyInCreation.contains(beanName); } 将创建中的bean加入到singletonsCurrentlyInCreation集合中 singletonFactoriesmap结构(三级缓存) /** Cache of singleton factories: bean name to ObjectFactory. */ private final Map> singletonFactories = new HashMap<>(16); 从earlySingletonObjects取不到则从singletonFactories取，存储的是 AbstractBeanFactory类的doGetBean方法 // Create bean instance. if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -> { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } 也是getSingleton方法，有个lambda表达式的createBean方法 DefaultSingletonBeanRegistry类的getSingleton方法逻辑 /** * Return the (raw) singleton object registered under the given name, * creating and registering a new one if none registered yet. * @param beanName the name of the bean * @param singletonFactory the ObjectFactory to lazily create the singleton * with, if necessary * @return the registered singleton object */ public Object getSingleton(String beanName, ObjectFactory singletonFactory) { Assert.notNull(beanName, \"Bean name must not be null\"); synchronized (this.singletonObjects) { // 1. 仍然是先判断是否在一级缓存中 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, \"Singleton bean creation not allowed while singletons of this factory are in destruction \" + \"(Do not request a bean from a BeanFactory in a destroy method implementation!)\"); } if (logger.isDebugEnabled()) { logger.debug(\"Creating shared instance of singleton bean '\" + beanName + \"'\"); } // 2. 创建前加入到`singletonsCurrentlyInCreation`集合中, 表示正在创建 beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) { this.suppressedExceptions = new LinkedHashSet<>(); } try { // 3. 执行lambda表达式的创建逻辑获取到单例bean，即执行`doCreateBean` singletonObject = singletonFactory.getObject(); newSingleton = true; } catch (IllegalStateException ex) { // Has the singleton object implicitly appeared in the meantime -> // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { throw ex; } } catch (BeanCreationException ex) { if (recordSuppressedExceptions) { for (Exception suppressedException : this.suppressedExceptions) { ex.addRelatedCause(suppressedException); } } throw ex; } finally { if (recordSuppressedExceptions) { this.suppressedExceptions = null; } // 4. 创建完成后从`singletonsCurrentlyInCreation`集合中移除, 非创建状态 afterSingletonCreation(beanName); } if (newSingleton) { // 5. 加入到一级缓存中，且从二级，三级缓存移除 addSingleton(beanName, singletonObject); } } // 6. 返回最终完整实例化的bean return singletonObject; } } AbstractAutowireCapableBeanFactory类的doCreateBean方法 /** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */ protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 1. factoryBeanInstanceCache 没有则需要主动创建 instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = instanceWrapper.getWrappedInstance(); Class beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); } mbd.postProcessed = true; } } // 加入到三级缓存:即添加,此为提前暴露早期对象 // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); } addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. Object exposedObject = bean; try { // 2. 填充bean的属性:即这里要完成bean依赖处理 populateBean(beanName, mbd, instanceWrapper); // 3. bean的initialize,beanPostProcessor等 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } if (earlySingletonExposure) { // 获取到AOP之后的代理对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { // 如果提前暴露的对象和经过了完整的生命周期后的对象相等，那么把代理对象赋值给`exposedObject` if (exposedObject == bean) { exposedObject = earlySingletonReference; } // 如果提前暴露的对象和经过了完整的生命周期后的对象不相等 // allowRawInjectionDespiteWrapping 表示在循环依赖时 else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set actualDependentBeans = new LinkedHashSet<>(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); } } } } // Register bean as disposable. try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); } return exposedObject; } Debug过程中的要点与截图 populateBean(\"b\", mbd, instanceWrapper)的时候，发现依赖了A，要去getBean(\"a\"),执行到getSingleton方法，此时从三级缓存中取到 从三级缓存取到A之后,执行了lambda(bean A)的逻辑，并将bean A加入二级缓存，并返回 由于从三级缓存拿到了提交曝光的A，B就正常的完成A依赖的设置，顺利完成populateBean方法 B实例化全部完成后，加入到单例缓存池(一级缓存)中 由于B实例化的完成，A的实例化也就能正常完成，并在最后也加入到单例缓存池(一级缓存)中 为什么是三级缓存？ Bean生命周期 A class --- BeanDefinition new A(); // 原始对象 populateBean（依赖注入）--> 单例池中找B --> 找不到 --> 创建B initializeBean BeanPostProcessor 完成并添加到单例池中 Bean生命周期 B class --- BeanDefinition new B(); // 原始对象 populateBean（依赖注入）--> 单例池中找A --> 找不到 --> 三级缓存中能找到 --> lambda(A) --> 提前得到代理A initializeBean BeanPostProcessor 完成并添加到单例池中 按照如上，如果只有 一级缓存 和 三级缓存，能够解决A,B依赖问题，接着又来了个C(且依赖A)；如果按照上面B的逻辑，那么可以发现lambda(A)会再次被执行，这可能导致B，C执行后获取的代理A不一致 Bean生命周期 C class --- BeanDefinition new C(); // 原始对象 populateBean（依赖注入）--> 单例池中找A --> 找不到 --> 三级缓存中能找到 --> lambda(A) --> 提前得到代理A initializeBean BeanPostProcessor 完成并添加到单例池中 所以再来一个缓存, 将代理对象也缓存起来，所以最后是三级缓存 单例池 map map 参考：bilibili 子路老师 scope bean 循环依赖有问题？ 测试代码 @Test public void testDependencySpringPrototype() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-dependency-prototype.xml\"); A a = (A) applicationContext.getBean(\"a\"); B b = (B) applicationContext.getBean(\"b\"); Assert.assertTrue(a != null); Assert.assertTrue(b != null); } spring-dependency-prototype.xml 异常栈 constructor A() constructor B() org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'a' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'b' while setting bean property 'b'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'b' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'a' while setting bean property 'a'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:378) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:110) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1648) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1400) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:575) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1094) at test.com.mb.DependencyTest.testDependencySpringPrototype(DependencyTest.java:44) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'b' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'a' while setting bean property 'a'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:378) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:110) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1648) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1400) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:575) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:367) ... 31 more Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:264) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:367) ... 39 more Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-01 23:50:19 "},"doc/bean/bean_life.html":{"url":"doc/bean/bean_life.html","title":"3.3 Bean生命周期","keywords":"","body":"bean的生命周期？ 以如下测试代码为例 @Test public void testClassPathXmlApplicationContextBean() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-full-life.xml\"); System.out.println(\"----------------applicationContext\"); FullBean fullBean = (FullBean)applicationContext.getBean(\"fullBean\"); System.out.println(\"fullBean.getName:\" + fullBean.getName()); ((ClassPathXmlApplicationContext) applicationContext).close(); } 其中单例fullBean依赖了单例fullBeanB且配置了相关初始化，销毁方法，和BeanPostProcessor fullBean生命周期 ClassPathXmlApplicationContext doGetBean(InstantiationAwareBeanPostProcessor doGetBean(BeanPostProcessor doGetBean(fullBean dependsOn createBean resolveBeforeInstantiation applyBeanPostProcessorsBeforeInstantiation（应用所有的InstantiationAwareBeanPostProcessor） postProcessBeforeInstantiation doCreateBean createBeanInstance(默认构造方法，反射创建一个对象) populateBean(设置属性，其中依赖Bean 走 dochteren逻辑) InstantiationAwareBeanPostProcessor：postProcessAfterInstantiation applyPropertyValues(beanName, mbd, bw, pvs); initializeBean applyBeanPostProcessorsBeforeInitialization（应用所有的BeanPostProcessor） postProcessBeforeInitialization invokeInitMethods InitializingBean(afterPropertiesSet) InitMethod 加入单例池 fullBean.getName ( bean的使用) ((ClassPathXmlApplicationContext) applicationContext).close() doClose Publish shutdown event. lifecycleProcessor.onClose(); destroyBeans DisposableBean destroy-method closeBeanFactory onClose() this.active.set(false); Runtime.getRuntime().removeShutdownHook(this.shutdownHook); 单例Bean生命周期 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-06 09:55:49 "},"doc/bean/bean_scope.html":{"url":"doc/bean/bean_scope.html","title":"3.3.1 Bean的作用域","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Bean Scope Spring 中的 singletion bean 的线程安全问题？ prototype Bean Scope bean scope doc scope description - singletion (Default) Scopes a single bean definition to a single object instance per Spring IoC container. 单例bean prototype Scopes a single bean definition to any number of object instances. 多例bean,每次请求都新产生bean request Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效 session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效 application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. - websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. - Spring 中的 singletion bean 的线程安全问题？ 存在线程问题; 对于一个无状态Bean(即对bean属，性只有读操作，无写操作)，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。 对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。 prototype Spring does not manage the complete lifecycle of a prototype bean @Component(\"userService\") @Scope(\"prototype\") public class UserServiceImpl implements UserService { @Autowired private UserRepo userRepo; @Override public User getUserById(Integer id){ User user = userRepo.getById(id); try { TimeUnit.SECONDS.sleep(2); } catch (Exception e) { e.printStackTrace(); } return user; } } AbstractBeanFactory类的doGetBean方法 else if (mbd.isPrototype()) { // It's a prototype -> create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } 总结：多线程, 生成多个实例，Ioc容器不负责完整的生命周期 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-08 13:16:12 "},"doc/bean/fatory_bean.html":{"url":"doc/bean/fatory_bean.html","title":"3.4 FactoryBean接口","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 FactoryBean FactoryBean 官方文档阅读 FactoryBean 实践 FactoryBean Customizing Instantiation Logic with a FactoryBean FactoryBean 官方文档阅读 功能：使用FactoryBean定制bean的实例化逻辑 The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex initialization inside that class, and then plug your custom FactoryBean into the container. The FactoryBean interface provides three methods: Object getObject(): Returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes. boolean isSingleton(): Returns true if this FactoryBean returns singletons or false otherwise. Class getObjectType(): Returns the object type returned by the getObject() method or null if the type is not known in advance. FactoryBean 实践 实现一个FactoryBean import org.springframework.beans.factory.FactoryBean; /** * @Author mubi * @Date 2020/7/4 13:01 */ public class MyGoFactoryBean implements FactoryBean { private String type; private Go getDefaultGo(){ return new Go() { @Override public void out() { System.out.println(\"just go on foot\"); } }; } public String getType() { return type; } public void setType(String type) { this.type = type; } @Override public Go getObject(){ if (type == null) { return getDefaultGo(); } if (type.equalsIgnoreCase(GoEnum.BIKE.getType())) { return new BikeGo(); } if (type.equalsIgnoreCase(GoEnum.CAR.getType())) { return new CarGo(); } return getDefaultGo(); } @Override public Class getObjectType() { return Go.class ; } @Override public boolean isSingleton() { return false; } } xml 测试 @Test public void testDependencySpring() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-factory-bean.xml\"); Go go = (Go) applicationContext.getBean(\"go\"); go.out(); } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-06 11:58:31 "},"doc/bean/aop.html":{"url":"doc/bean/aop.html","title":"3.5 AOP","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 AOP Spring AOP 各种概念 断点调试技巧 目标对象 =》代理对象 AOP Spring AOP 各种概念 spring aop reference Aspect Join point(连接点) A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution. 通常就是一个执行的方法 Advice(增强器) Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point. 在特定的join point增强 1. Before 2. After 3. AfterReturn 4. AfterThrowing 5. Around Pointcut(切点) A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default. 简单认为是：某些特定的join point的集合 Introduction Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.) Target object An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object. 增强对象(新对象，代理对象)，被增强的那个原始对象就是Target object AOP proxy An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy. Weaving linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime. 断点调试技巧 断点加条件 Evaluate，断点评估运行 目标对象 =》代理对象 debug 可以定位到initializeBean方法后，返回了代理对象 // Initialize the bean instance. Object exposedObject = bean; try { // 2. 填充bean的属性:即这里要完成bean依赖处理 populateBean(beanName, mbd, instanceWrapper); // 3. bean的initialize,beanPostProcessor等 // 执行完如下一句，exposedObject 是JdkDynamicAopProxy对象 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } 继续debug在applyBeanPostProcessorsAfterInitialization方法返回了代理对象 在某个PostProcessor作用后肯定会变成代理对象 /** * Create a proxy with the configured interceptors if the bean is * identified as one to proxy by the subclass. * @see #getAdvicesAndAdvisorsForBean */ @Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean; } Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); 附：@EnableAspectJAutoProxy(proxyTargetClass=true) 使用CGLib代理, 创建AopProxy public class DefaultAopProxyFactory implements AopProxyFactory, Serializable { @Override public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) { Class targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\"TargetSource cannot determine target class: \" + \"Either an interface or a target is required for proxy creation.\"); } // 目标类是一个接口则会使用`JdkDynamicAopProxy`创建代理对象 if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-08 10:18:48 "},"doc/bean/aspectj.html":{"url":"doc/bean/aspectj.html","title":"3.5.1  AOP 和 AspectJ AOP ","keywords":"","body":"Aop 代理 Spring AOP 属于运行时增强，而 AspectJ 是编译时增强 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation) 附：动态字节码生成代理 编译 ClassLoader加载 实例 .java ------> .class(字节码) -------------------> Class Obj ------------> Class Instance 类别 机制 原理 优点 缺点 技术 静态AOP 静态织入 在编译期,切面直接以字节码的形式编译到目标字节码文件中 对系统无性能影响 灵活性不够 AspectJ 动态AOP 动态代理 在运行期,目标类加载后，为接口动态生成代理类，将切面植入到代理类中 相对于静态AOP更加灵活 切入的关注点需要实现接口。对系统有一点性能影响 JDK dynamic proxy 动态字节码生成 在运行期 - 目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中 没有接口也可以织入 扩展类的实例方法为final时，则无法进行织入 cglib 自定义类加载器 在运行期 - 目标加载前，将切面逻辑加到目标字节码里 可以对绝大部分类进行织入 代码中如果使用了其他类加载器，则这些类将不会被织入 - 字节码转换 在运行期 - 所有类加载器加载字节码前，前进行拦截 可以对所有类进行织入 - Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-08 13:57:53 "},"doc/bean/bean_definition.html":{"url":"doc/bean/bean_definition.html","title":"3.6 BeanDefinition","keywords":"","body":"BeanDefinition BeanDefinition定义了Bean的各种属性，以及如何去创造生成该bean的相关信息 属性 说明 Class 类 Name 名称 Scope bean作用域 Constructor arguments 构造器参数 Properties 成员属性 Autowiring mode 自动装配模式 Lazy initialization mode 懒加载模式 initialization method 初始化方法 Destruction methods 销毁方法 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-17 13:35:21 "},"doc/bean/configuration.html":{"url":"doc/bean/configuration.html","title":"3.7 @Configuration","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 @Configuration @Configuration注解使用与代理现象 @Configuration到底做了什么操作 【*】@Configuration的Bean怎么加入到beanDefinitionMap中 register(annotatedClasses); refresh()方法的invokeBeanFactoryPostProcessors(beanFactory);发生了BeanDefinitionMap的改变 invokeBeanFactoryPostProcessors(beanFactory); 进入PostProcessorRegistrationDelegate到invokeBeanFactoryPostProcessors方法 进入到ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(registry)方法 @Configuration的beanDefinition添加全注解属性 ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);方法实现了代理 【*】enhanceConfigurationClasses(beanFactory);完成了对@Configuration类的Cglib代理 【*】processConfigBeanDefinitions(registry);内继续debug看x()方法的@Bean`加载到beanDefinitionMap 在类DefaultListableBeanFactory的registerBeanDefinition方法中可以看到beanDefinitionMap.put(\"x\", beanDefinition) BeanDefinition全部到位后，接下来就是单例bean生命周期了 @Configuration @Configuration注解使用与代理现象 package com.test.config; import com.test.entity.X; import com.test.entity.Y; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @Author mubi * @Date 2020/7/8 22:38 */ @Configuration public class XyzConfig { @Bean public X x(){ return new X(); } @Bean public Y y(){ x(); return new Y(); } } 测试输出如下(X,Y两个对象都只初始化一次) init X init Y @Configuration 会代理XyzConfig对象，确定里面的@Bean是单例的 debug 查看XyzConfigBean使用了Cglib代理 @Test public void testXyzConfig(){ AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(XyzConfig.class); XyzConfig config = ac.getBean(XyzConfig.class); X x = (X)ac.getBean(\"x\"); Y y = (Y)ac.getBean(\"y\"); Assert.assertTrue(x != null); Assert.assertTrue(y != null); } @Configuration到底做了什么操作 常规思路：一步一步debug源码，可能的地方，断点反复看；不过还是需要一定基础和目标 首先要知道：bean一定有个BeanDefinition；其次Spring是有MapperScan,ComponentScan这种扫描注解功能的 所以@Configuration是扫描出来并加载的吗？ 显然Spring提供扫描Bean功能，这需要一个至少一个@Configuration类，所以@Configuration肯定不是扫描方式的；事实上其实手动register的 带着问题看源码，同时还有问题是：bean x,y 是什么时候生成BeanDefinition并写入到BeanDefinitionMap中的 【*】@Configuration的Bean怎么加入到beanDefinitionMap中 在newAnnotationConfigApplicationContext的时候会执行register(annotatedClasses);方法，紧接着是refresh方法; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(XyzConfig.class); register(annotatedClasses); 会执行doRegisterBean方法注册BeanDefinition； 回答：`@Configuration`的Bean是直接手动注册的，而非scan扫描方式 void doRegisterBean(Class annotatedClass, @Nullable Supplier instanceSupplier, @Nullable String name, @Nullable Class[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) { AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass); if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) { return; } abd.setInstanceSupplier(instanceSupplier); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd); abd.setScope(scopeMetadata.getScopeName()); String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry)); AnnotationConfigUtils.processCommonDefinitionAnnotations(abd); if (qualifiers != null) { for (Class qualifier : qualifiers) { if (Primary.class == qualifier) { abd.setPrimary(true); } else if (Lazy.class == qualifier) { abd.setLazyInit(true); } else { abd.addQualifier(new AutowireCandidateQualifier(qualifier)); } } } for (BeanDefinitionCustomizer customizer : definitionCustomizers) { customizer.customize(abd); } BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); } BeanDefinition首先会构造出来,并设置属性，包括如下 scope lazyInit dependsOn ... @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { this.beanFactory.registerBeanDefinition(beanName, beanDefinition); } BeanDefinition加入到beanFactory的beanDefinitionMap中 @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { ... // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName); 经过register(annotatedClasses);方法后，入下图 xyzConfig的BeanDefinition已经加入到BeanFactory的beanDefinitionMap中了 Bean x, y 还没有加入到beanDefinitionMap中 xyzConfig的BeanDefinition看起来是XyzConfig类自身，没有什么代理 refresh()方法的invokeBeanFactoryPostProcessors(beanFactory);发生了BeanDefinitionMap的改变 当debug执行完这一行后，发现beanFactory的beanDefinitionMap有变化，如下图 bean x,y 加入到beanDefinitionMap中了 同时发现xyzConfig被Spring增强了，可能发生了什么代理行为 invokeBeanFactoryPostProcessors(beanFactory); /** * Instantiate and invoke all registered BeanFactoryPostProcessor beans, * respecting explicit order if given. * Must be called before singleton instantiation. */ protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } 进入PostProcessorRegistrationDelegate到invokeBeanFactoryPostProcessors方法 其中beanFactoryPostProcessors是空的 public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List beanFactoryPostProcessors) { // 此方法的这句导致了`beanDefinitionMap`的变化 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 此次是ConfigurationClassPostProcessor,即@Configuration类的后置处理器 /** * Invoke the given BeanDefinitionRegistryPostProcessor beans. */ private static void invokeBeanDefinitionRegistryPostProcessors( Collection postProcessors, BeanDefinitionRegistry registry) { for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeanDefinitionRegistry(registry); } } 进入到ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(registry)方法 /** * Derive further bean definitions from the configuration classes in the registry. */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { int registryId = System.identityHashCode(registry); if (this.registriesPostProcessed.contains(registryId)) { throw new IllegalStateException( \"postProcessBeanDefinitionRegistry already called on this post-processor against \" + registry); } if (this.factoriesPostProcessed.contains(registryId)) { throw new IllegalStateException( \"postProcessBeanFactory already called on this post-processor against \" + registry); } this.registriesPostProcessed.add(registryId); processConfigBeanDefinitions(registry); } processConfigBeanDefinitions(registry);处理如下 会判断是否有@Configuration classes（本例有且只有一个xyzConfigbean） 获取Configuration配置的bean加入到Set candidates 对candidates中的BeanDefinitionHolder进行校验和bean扫描加载 @Configuration的beanDefinition添加全注解属性 for (String beanName : candidateNames) { BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) { if (logger.isDebugEnabled()) { logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef); } } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } } 在遍历beanDefinitionMap中的已经加入的所有bean中，逐一遍历判断是否是全注解类 第一次判断肯定不是，因为xyzConfig虽然有@Configuration，但是并没有进行任何解析和设置操作 判断不是，而后的checkConfigurationClassCandidate做了操作 ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) /** * Check whether the given bean definition is a candidate for a configuration class * (or a nested component class declared within a configuration/component class, * to be auto-registered as well), and mark it accordingly. * @param beanDef the bean definition to check * @param metadataReaderFactory the current factory in use by the caller * @return whether the candidate qualifies as (any kind of) configuration class */ public static boolean checkConfigurationClassCandidate( BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) { // isFullConfigurationCandidate 判断语句：metadata.isAnnotated(Configuration.class.getName()); // 判断是否有@Configuration,这里会判断xyzConfig类是一个全注解类 // 重新设置全注解类的属性，下次就需要再checkConfigurationClassCandidate了 if (isFullConfigurationCandidate(metadata)) { beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL); } invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);方法实现了代理 在ConfigurationClassPostProcessor类中看到了enhanceConfigurationClasses(beanFactory); @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) { throw new IllegalStateException( \"postProcessBeanFactory already called on this post-processor against \" + beanFactory); } this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) { // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); } enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); } 【*】enhanceConfigurationClasses(beanFactory);完成了对@Configuration类的Cglib代理 debug进入方法可以看到会对beanFactory中所有bean判断是否是全注解 因为之前xyzConfig是已经设置了全注解的，所以这里肯定判断是，并加入到configBeanDefs 只要configBeanDefs不是空，程序继续走，就有了代理；如下图的debug，实时也确实如此 直接new了ConfigurationClassEnhancer（即使用的是Cglib代理） 这里也看到了xyzConfig全注解bean的beanDefinitiond的beanClass属性变成了代理类 /** * Post-processes a BeanFactory in search of Configuration class BeanDefinitions; * any candidates are then enhanced by a {@link ConfigurationClassEnhancer}. * Candidate status is determined by BeanDefinition attribute metadata. * @see ConfigurationClassEnhancer */ public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) { Map configBeanDefs = new LinkedHashMap<>(); for (String beanName : beanFactory.getBeanDefinitionNames()) { BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) { if (!(beanDef instanceof AbstractBeanDefinition)) { throw new BeanDefinitionStoreException(\"Cannot enhance @Configuration bean definition '\" + beanName + \"' since it is not stored in an AbstractBeanDefinition subclass\"); } else if (logger.isInfoEnabled() && beanFactory.containsSingleton(beanName)) { logger.info(\"Cannot enhance @Configuration bean definition '\" + beanName + \"' since its singleton instance has been created too early. The typical cause \" + \"is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor \" + \"return type: Consider declaring such methods as 'static'.\"); } configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); } } if (configBeanDefs.isEmpty()) { // nothing to enhance -> return immediately return; } ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry entry : configBeanDefs.entrySet()) { AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); try { // Set enhanced subclass of the user-specified bean class Class configClass = beanDef.resolveBeanClass(this.beanClassLoader); if (configClass != null) { Class enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) { if (logger.isTraceEnabled()) { logger.trace(String.format(\"Replacing bean definition '%s' existing class '%s' with \" + \"enhanced class '%s'\", entry.getKey(), configClass.getName(), enhancedClass.getName())); } beanDef.setBeanClass(enhancedClass); } } } catch (Throwable ex) { throw new IllegalStateException(\"Cannot load configuration class: \" + beanDef.getBeanClassName(), ex); } } } 【*】processConfigBeanDefinitions(registry);内继续debug看x()方法的@Bean`加载到beanDefinitionMap ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForBeanMethod方法 此方法会判断是否有覆盖的beanDefinition // Has this effectively been overridden before (e.g. via XML)? if (isOverriddenByExistingDefinition(beanMethod, beanName)) { if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) { throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(), beanName, \"Bean name derived from @Bean method '\" + beanMethod.getMetadata().getMethodName() + \"' clashes with bean name for containing configuration class; please make those names unique!\"); } return; } 构造并注册bean x 在类DefaultListableBeanFactory的registerBeanDefinition方法中可以看到beanDefinitionMap.put(\"x\", beanDefinition) BeanDefinition全部到位后，接下来就是单例bean生命周期了 参考复习：单例bean生命周期 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-18 10:36:13 "},"doc/bean/transaction.html":{"url":"doc/bean/transaction.html","title":"4 Spring 事务","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Spring事务 数据库事务 Spring Transaction Management jdbc事务配置和使用 Spring事务抽象接口 PlatformTransactionManager(事务管理器接口) DataSourceTransactionManager TransactionDefinition(事务定义信息接口) TransactionStatus(事务运行状态接口) @EnableTransactionManagement AutoProxyRegistrar 注册一个InfrastructureAdvisorAutoProxyCreator组件 ProxyTransactionManagementConfiguration(注册事务增强器) TransactionInterceptor Spring事务 数据库事务 A, Atomicity 事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行 C, Consistency 几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致 I, Isolation 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的 D, Durability 对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 MySQL 四种隔离级别及测试 3个事务问题 脏读：读取到了未提交事务的数据，比如未提交读就可能会产生这种数据 不可重复读：在同一个事务里两次读取的数据不一样，因为在两次读取的过程中，另一个事务提交改变了该值(update操作)。未提交读，已提交读又称为不可重复读，会产生这种情况。 幻读：与不可重复读类似，幻读是两次查询的行个数不一样(针对的是insert操作)。幻读针对的是多行，不可重复读针对的是一行或者一个数据。 4种隔离级别 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。 Read committed (读取已提交的)：可避免脏读的发生。 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。 Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable read(MySQL默认) × × √ Serializable × × × √: 可能出现 ×: 不会出现 Spring Transaction Management Transaction Management Doc The most important concepts to grasp with regard to the Spring Framework’s declarative transaction support are that this support is enabled via AOP proxies and that the transactional advice is driven by metadata (currently XML- or annotation-based). The combination of AOP with transactional metadata yields an AOP proxy that uses a TransactionInterceptor in conjunction with an appropriate PlatformTransactionManager implementation to drive transactions around method invocations. （Spring的声明式事务的支持依靠：AOP代理和transactional增强器(通过xml或者annotation配置的增强器)） jdbc事务配置和使用 @EnableTransactionManagement @ComponentScan(\"com.test\") @Configuration public class TxConfig { @Bean public DataSource dataSource(){ DriverManagerDataSource ds = new DriverManagerDataSource (); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/test\"); ds.setUsername(\"root\"); ds.setPassword(\"\"); return ds; } @Bean public JdbcTemplate jdbcTemplate(){ JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; } /** * 注册事务管理器到容器中 */ @Bean public PlatformTransactionManager transactionManager(){ return new DataSourceTransactionManager(dataSource()); } } 测试使用,方法上加上@Transactional @Transactional(rollbackFor = Exception.class) public Boolean insertAUser(TbUser tbUser){ String sql = \"insert into t_user(sno, name, password) values(?,?,?)\"; int cnt = jdbcTemplate.update(sql, tbUser.getSno(), tbUser.getName(), tbUser.getPassword()); int arr[] = {1,2}; int c = arr[2]; return cnt > 0 ? true : false; } Spring事务抽象接口 PlatformTransactionManager(事务管理器接口) 三个抽象方法：1. 获取事务状态，2. 提交事务，3. 回滚事务 public interface PlatformTransactionManager { /** * Return a currently active transaction or create a new one, according to * the specified propagation behavior. * Note that parameters like isolation level or timeout will only be applied * to new transactions, and thus be ignored when participating in active ones. * Furthermore, not all transaction definition settings will be supported * by every transaction manager: A proper transaction manager implementation * should throw an exception when unsupported settings are encountered. * An exception to the above rule is the read-only flag, which should be * ignored if no explicit read-only mode is supported. Essentially, the * read-only flag is just a hint for potential optimization. * @param definition the TransactionDefinition instance (can be {@code null} for defaults), * describing propagation behavior, isolation level, timeout etc. * @return transaction status object representing the new or current transaction * @throws TransactionException in case of lookup, creation, or system errors * @throws IllegalTransactionStateException if the given transaction definition * cannot be executed (for example, if a currently active transaction is in * conflict with the specified propagation behavior) * @see TransactionDefinition#getPropagationBehavior * @see TransactionDefinition#getIsolationLevel * @see TransactionDefinition#getTimeout * @see TransactionDefinition#isReadOnly */ TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; /** * Commit the given transaction, with regard to its status. If the transaction * has been marked rollback-only programmatically, perform a rollback. * If the transaction wasn't a new one, omit the commit for proper * participation in the surrounding transaction. If a previous transaction * has been suspended to be able to create a new one, resume the previous * transaction after committing the new one. * Note that when the commit call completes, no matter if normally or * throwing an exception, the transaction must be fully completed and * cleaned up. No rollback call should be expected in such a case. * If this method throws an exception other than a TransactionException, * then some before-commit error caused the commit attempt to fail. For * example, an O/R Mapping tool might have tried to flush changes to the * database right before commit, with the resulting DataAccessException * causing the transaction to fail. The original exception will be * propagated to the caller of this commit method in such a case. * @param status object returned by the {@code getTransaction} method * @throws UnexpectedRollbackException in case of an unexpected rollback * that the transaction coordinator initiated * @throws HeuristicCompletionException in case of a transaction failure * caused by a heuristic decision on the side of the transaction coordinator * @throws TransactionSystemException in case of commit or system errors * (typically caused by fundamental resource failures) * @throws IllegalTransactionStateException if the given transaction * is already completed (that is, committed or rolled back) * @see TransactionStatus#setRollbackOnly */ void commit(TransactionStatus status) throws TransactionException; /** * Perform a rollback of the given transaction. * If the transaction wasn't a new one, just set it rollback-only for proper * participation in the surrounding transaction. If a previous transaction * has been suspended to be able to create a new one, resume the previous * transaction after rolling back the new one. * Do not call rollback on a transaction if commit threw an exception. * The transaction will already have been completed and cleaned up when commit * returns, even in case of a commit exception. Consequently, a rollback call * after commit failure will lead to an IllegalTransactionStateException. * @param status object returned by the {@code getTransaction} method * @throws TransactionSystemException in case of rollback or system errors * (typically caused by fundamental resource failures) * @throws IllegalTransactionStateException if the given transaction * is already completed (that is, committed or rolled back) */ void rollback(TransactionStatus status) throws TransactionException; } DataSourceTransactionManager DataSourceTransactionManager 针对 JdbcTemplate,Mybatis 事务空寂，使用Connection进行事务控制 开启事务：connection.setAutoCommit(false) 提交事务：connection.commit 回滚事务：connection.rollback() TransactionDefinition(事务定义信息接口) 事务的定义信息（隔离，传播，超时，只读） /** * Interface that defines Spring-compliant transaction properties. * Based on the propagation behavior definitions analogous to EJB CMT attributes. * * Note that isolation level and timeout settings will not get applied unless * an actual new transaction gets started. As only {@link #PROPAGATION_REQUIRED}, * {@link #PROPAGATION_REQUIRES_NEW} and {@link #PROPAGATION_NESTED} can cause * that, it usually doesn't make sense to specify those settings in other cases. * Furthermore, be aware that not all transaction managers will support those * advanced features and thus might throw corresponding exceptions when given * non-default values. * * The {@link #isReadOnly() read-only flag} applies to any transaction context, * whether backed by an actual resource transaction or operating non-transactionally * at the resource level. In the latter case, the flag will only apply to managed * resources within the application, such as a Hibernate {@code Session}. * * @author Juergen Hoeller * @since 08.05.2003 * @see PlatformTransactionManager#getTransaction(TransactionDefinition) * @see org.springframework.transaction.support.DefaultTransactionDefinition * @see org.springframework.transaction.interceptor.TransactionAttribute */ public interface TransactionDefinition { TransactionStatus(事务运行状态接口) @EnableTransactionManagement @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(TransactionManagementConfigurationSelector.class) public @interface EnableTransactionManagement { 利用TransactionManagementConfigurationSelector导入组件，默认增强器模式是PROXY，导入了AutoProxyRegistrar和ProxyTransactionManagementConfiguration` 两个组件 public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector { /** * Returns {@link ProxyTransactionManagementConfiguration} or * {@code AspectJ(Jta)TransactionManagementConfiguration} for {@code PROXY} * and {@code ASPECTJ} values of {@link EnableTransactionManagement#mode()}, * respectively. */ @Override protected String[] selectImports(AdviceMode adviceMode) { switch (adviceMode) { case PROXY: return new String[] {AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()}; case ASPECTJ: return new String[] {determineTransactionAspectClass()}; default: return null; } } private String determineTransactionAspectClass() { return (ClassUtils.isPresent(\"javax.transaction.Transactional\", getClass().getClassLoader()) ? TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME : TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME); } } AutoProxyRegistrar 注册一个InfrastructureAdvisorAutoProxyCreator组件 @Nullable public static BeanDefinition registerAutoProxyCreatorIfNecessary( BeanDefinitionRegistry registry, @Nullable Object source) { return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source); } 查看InfrastructureAdvisorAutoProxyCreator类图，其是一个BeanPostProcessor ProxyTransactionManagementConfiguration(注册事务增强器) 在容器中注册事务增强器 1. 事务注解和解析 2. 注册了事务拦截器`TransactionInterceptor` 保存事务管理器，事务属性信息,是一个`MethodInterceptor`在目标方法执行的时候 执行拦截器链, 其中事务拦截器操作如下 1. 获取事务相关的属性 2. 获取PlatformTransactionManager 3. 执行目标方法 a. 如果异常，获取到事务管理器，利用事务管理回滚操作 b. 如果正常，利用事务管理器，正常提交事务 TransactionInterceptor @Override @Nullable public Object invoke(MethodInvocation invocation) throws Throwable { // Work out the target class: may be {@code null}. // The TransactionAttributeSource should be passed the target class // as well as the method, which may be from an interface. Class targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); // Adapt to TransactionAspectSupport's invokeWithinTransaction... return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed); } invokeWithinTransaction方法对目标对象方法进行拦截 /** * General delegate for around-advice-based subclasses, delegating to several other template * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager} * as well as regular {@link PlatformTransactionManager} implementations. * @param method the Method being invoked * @param targetClass the target class that we're invoking the method on * @param invocation the callback to use for proceeding with the target invocation * @return the return value of the method, if any * @throws Throwable propagated from the target invocation */ @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class targetClass, final InvocationCallback invocation) throws Throwable { // If the transaction attribute is null, the method is non-transactional. TransactionAttributeSource tas = getTransactionAttributeSource(); final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); final PlatformTransactionManager tm = determineTransactionManager(txAttr); final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) { // Standard transaction demarcation with getTransaction and commit/rollback calls. TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try { // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // target invocation exception completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } commitTransactionAfterReturning(txInfo); return retVal; } else { final ThrowableHolder throwableHolder = new ThrowableHolder(); // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in. try { Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -> { TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status); try { return invocation.proceedWithInvocation(); } catch (Throwable ex) { if (txAttr.rollbackOn(ex)) { // A RuntimeException: will lead to a rollback. if (ex instanceof RuntimeException) { throw (RuntimeException) ex; } else { throw new ThrowableHolderException(ex); } } else { // A normal return value: will lead to a commit. throwableHolder.throwable = ex; return null; } } finally { cleanupTransactionInfo(txInfo); } }); // Check result state: It might indicate a Throwable to rethrow. if (throwableHolder.throwable != null) { throw throwableHolder.throwable; } return result; } catch (ThrowableHolderException ex) { throw ex.getCause(); } catch (TransactionSystemException ex2) { if (throwableHolder.throwable != null) { logger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable); ex2.initApplicationException(throwableHolder.throwable); } throw ex2; } catch (Throwable ex2) { if (throwableHolder.throwable != null) { logger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable); } throw ex2; } } } 处理异常：commit or roll back /** * Handle a throwable, completing the transaction. * We may commit or roll back, depending on the configuration. * @param txInfo information about the current transaction * @param ex throwable encountered */ protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) { if (txInfo != null && txInfo.getTransactionStatus() != null) { if (logger.isTraceEnabled()) { logger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() + \"] after exception: \" + ex); } if (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) { try { txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus()); } catch (TransactionSystemException ex2) { logger.error(\"Application exception overridden by rollback exception\", ex); ex2.initApplicationException(ex); throw ex2; } catch (RuntimeException | Error ex2) { logger.error(\"Application exception overridden by rollback exception\", ex); throw ex2; } } else { // We don't roll back on this exception. // Will still roll back if TransactionStatus.isRollbackOnly() is true. try { txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()); } catch (TransactionSystemException ex2) { logger.error(\"Application exception overridden by commit exception\", ex); ex2.initApplicationException(ex); throw ex2; } catch (RuntimeException | Error ex2) { logger.error(\"Application exception overridden by commit exception\", ex); throw ex2; } } } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-11 09:24:20 "},"doc/bean/transaction_annotation.html":{"url":"doc/bean/transaction_annotation.html","title":"4.1 @Transactional","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 @Transactional 事务的传播特性 什么是事务的传播特性？ Spring给出的7种事务的传播类型 Spring的5种事务隔离级别 rollbackFor属性 @Transactional 事务的传播特性 什么是事务的传播特性？ 指的是当一个事务方法被另一个事务方法调用时，这个事务方法该如何进行？ @Transactional public void A(){ // xx B(); C(); // xx // 出现异常 } @Transactional public void B(){ // xx // 出现异常 } @Transactional public void C(){ // xx // 出现异常 } 如上：事务A内部有事务B,事务C；如果A异常了，那么B,C怎么处理事务；如果B，C事务异常，那么事务A怎么处理？ Spring给出的7种事务的传播类型 /** * Enumeration that represents transaction propagation behaviors for use * with the {@link Transactional} annotation, corresponding to the * {@link TransactionDefinition} interface. * * @author Colin Sampaleanu * @author Juergen Hoeller * @since 1.2 */ public enum Propagation { /** * * Support a current transaction, create a new one if none exists. * Analogous to EJB transaction attribute of the same name. * This is the default setting of a transaction annotation. */ REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED), /** * Support a current transaction, execute non-transactionally if none exists. * Analogous to EJB transaction attribute of the same name. * Note: For transaction managers with transaction synchronization, * PROPAGATION_SUPPORTS is slightly different from no transaction at all, * as it defines a transaction scope that synchronization will apply for. * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc) * will be shared for the entire specified scope. Note that this depends on * the actual synchronization configuration of the transaction manager. * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization */ SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS), /** * Support a current transaction, throw an exception if none exists. * Analogous to EJB transaction attribute of the same name. */ MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY), /** * Create a new transaction, and suspend the current transaction if one exists. * Analogous to the EJB transaction attribute of the same name. * NOTE: Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available it to it (which is server-specific in standard Java EE). * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */ REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW), /** * Execute non-transactionally, suspend the current transaction if one exists. * Analogous to EJB transaction attribute of the same name. * NOTE: Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available it to it (which is server-specific in standard Java EE). * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */ NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED), /** * Execute non-transactionally, throw an exception if a transaction exists. * Analogous to EJB transaction attribute of the same name. */ NEVER(TransactionDefinition.PROPAGATION_NEVER), /** * Execute within a nested transaction if a current transaction exists, * behave like PROPAGATION_REQUIRED else. There is no analogous feature in EJB. * Note: Actual creation of a nested transaction will only work on specific * transaction managers. Out of the box, this only applies to the JDBC * DataSourceTransactionManager when working on a JDBC 3.0 driver. * Some JTA providers might support nested transactions as well. * @see org.springframework.jdbc.datasource.DataSourceTransactionManager */ NESTED(TransactionDefinition.PROPAGATION_NESTED); private final int value; Propagation(int value) { this.value = value; } public int value() { return this.value; } } 传播属性 描述 required(默认) 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。 requires_new 不管当前是否已经存在事务，都会新建一个事务；开启的事务相互独立，互不干扰。 Mandatory 支持当前事务，如果当前没有事务，就抛出异常。 Never 以非事务方式执行，如果当前存在事务，则抛出异常。 Not_supports 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 Supports 支持当前事务，如果当前没有事务，就以非事务方式执行。 Nested 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。 Spring的5种事务隔离级别 /** * Enumeration that represents transaction isolation levels for use * with the {@link Transactional} annotation, corresponding to the * {@link TransactionDefinition} interface. * * @author Colin Sampaleanu * @author Juergen Hoeller * @since 1.2 */ public enum Isolation { /** * 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别 * * Use the default isolation level of the underlying datastore. * All other levels correspond to the JDBC isolation levels. * @see java.sql.Connection */ DEFAULT(TransactionDefinition.ISOLATION_DEFAULT), /** * A constant indicating that dirty reads, non-repeatable reads and phantom reads * can occur. This level allows a row changed by one transaction to be read by * another transaction before any changes in that row have been committed * (a \"dirty read\"). If any of the changes are rolled back, the second * transaction will have retrieved an invalid row. * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED */ READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED), /** * A constant indicating that dirty reads are prevented; non-repeatable reads * and phantom reads can occur. This level only prohibits a transaction * from reading a row with uncommitted changes in it. * @see java.sql.Connection#TRANSACTION_READ_COMMITTED */ READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED), /** * A constant indicating that dirty reads and non-repeatable reads are * prevented; phantom reads can occur. This level prohibits a transaction * from reading a row with uncommitted changes in it, and it also prohibits * the situation where one transaction reads a row, a second transaction * alters the row, and the first transaction rereads the row, getting * different values the second time (a \"non-repeatable read\"). * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ */ REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ), /** * A constant indicating that dirty reads, non-repeatable reads and phantom * reads are prevented. This level includes the prohibitions in * {@code ISOLATION_REPEATABLE_READ} and further prohibits the situation * where one transaction reads all rows that satisfy a {@code WHERE} * condition, a second transaction inserts a row that satisfies that * {@code WHERE} condition, and the first transaction rereads for the * same condition, retrieving the additional \"phantom\" row in the second read. * @see java.sql.Connection#TRANSACTION_SERIALIZABLE */ SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE); private final int value; Isolation(int value) { this.value = value; } public int value() { return this.value; } } rollbackFor属性 /** * Defines zero (0) or more exception {@link Class classes}, which must be * subclasses of {@link Throwable}, indicating which exception types must cause * a transaction rollback. * By default, a transaction will be rolling back on {@link RuntimeException} * and {@link Error} but not on checked exceptions (business exceptions). See * {@link org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)} * for a detailed explanation. * This is the preferred way to construct a rollback rule (in contrast to * {@link #rollbackForClassName}), matching the exception class and its subclasses. * Similar to {@link org.springframework.transaction.interceptor.RollbackRuleAttribute#RollbackRuleAttribute(Class clazz)}. * @see #rollbackForClassName * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable) */ Class[] rollbackFor() default {}; roll back默认是Error和RuntimeException eg1: 不加rollbackFor属性，抛出RuntimeException，正常回滚 @Transactional eg2: 不加rollbackFor属性，抛出IOException，不回滚 @Transactional eg3: 加上rollbackFor = Exception.class，抛出IOException，正常回滚 @Transactional(rollbackFor = Exception.class) eg4: 不加rollbackFor属性，抛出OutOfMemoryError，正常回滚 @Transactional() throw new OutOfMemoryError(); eg5: 加上rollbackFor = Exception.class，抛出OutOfMemoryError，正常回滚 @Transactional(rollbackFor = Exception.class) throw new OutOfMemoryError(); Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-11 08:54:04 "},"doc/mybatis.html":{"url":"doc/mybatis.html","title":"5 MyBatis","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 MyBatis ORM概念 Jdbc传统做法 Mybatis ORM框架 自己实现MyBatis Session的getMapper方法，生产Mapper代理对象 Mapper方法的执行利用反射(1.解析sql,2.jdbc执行) 利用FactoryBean获取成千上万的不同Mapper对象 ImportBeanDefinitionRegistrar 注册FactoryBean到Spring中 支持MapperScan注解 测试 MyBatis ORM概念 对象关系映射（Object Relational Mapping，简称ORM）是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。 这也同时暗示着额外的执行开销；然而，如果ORM作为一种中间件实现，则会有很多机会做优化，而这些在手写的持久层并不存在。 更重要的是用于控制转换的元数据需要提供和管理；但是同样，这些花费要比维护手写的方案要少；而且就算是遵守ODMG规范的对象数据库依然需要类级别的元数据。 Jdbc传统做法 导入jdbc驱动包 通过DriverManager注册驱动 创建连接 创建statement 执行curd sql语句 操作结果集 关闭连接 Mybatis ORM框架 mybatis 官方文档 mybatis 结合 Spring 官方文档 MyBatis原理：Jdk动态代理产生Mapper的代理对象 解析sql语句 执行sql(数据库连接) 结合Spring:mybatis产生的代理对象怎么放到Spring容器中 自己产生的对象(自己new,而不是spring new出来的)怎么交给Spring管理？ 单个bean: @Bean 成千上万的bean: @FactoryBean（mybatis中的MapperFactoryBean） 用spring的beanFactory注册bean: beanFactory.registerSingleton(Object) 自己实现MyBatis Session的getMapper方法，生产Mapper代理对象 package com.test.mybatis; import java.lang.reflect.Proxy; /** * @Author mubi * @Date 2020/7/11 13:45 */ public class DbSession { public static Object getMapper(Class clazz) { Class[] clazzs = new Class[]{clazz}; // 类加载器，被代理类，InvocationHandler方法改变增强 Object object = Proxy.newProxyInstance(DbSession.class.getClassLoader(), clazzs, new DbInvocationHandler()); return object; } } Mapper方法的执行利用反射(1.解析sql,2.jdbc执行) Mapper类 public interface UserMapper { /** * select 映射 * @param id * @return */ @Select(\"SELECT * FROM t_user WHERE id = #{id}\") TbUser selectUserById(int id); } Mapper类动态代理:方法(解析sql, 执行jdbc, 返回结果) package com.test.mybatis; import com.test.entity.TbUser; import org.apache.ibatis.annotations.Select; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; /** * @Author mubi * @Date 2020/7/11 13:45 */ public class DbInvocationHandler implements InvocationHandler { /** * mapper 里面的方法，逻辑是一个 * 1. 解析sql * 2. 执行sql（jdbc连接) */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 1. parse sql Select annotation = method.getAnnotation(Select.class); String sql = annotation.value()[0]; Object val = args[0]; String parseSql = sql.replace(\"#{id}\", String.valueOf(val)); System.out.println(\"parse sql:\" + parseSql); // 2. execute sql return exeSql(parseSql); } static TbUser exeSql(String sql) { Connection conn = null; Statement stmt = null; Integer id = 0; String name = null; String sno = null; String password = null; try { //STEP 1: Register JDBC driver Class.forName(\"com.mysql.jdbc.Driver\"); //STEP 2: Open a connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"\"); //STEP 3: Execute a query stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql); //STEP 4: Get results while (rs.next()) { id = Integer.valueOf(rs.getString(\"id\")); sno = rs.getString(\"sno\"); name = rs.getString(\"name\"); password = rs.getString(\"password\"); break; } rs.close(); } catch (Exception e) { }//end try return new TbUser(id, sno, name, password); } } 利用FactoryBean获取成千上万的不同Mapper对象 package com.test.mybatis; import org.springframework.beans.factory.FactoryBean; /** * @Author mubi * @Date 2020/7/11 13:45 * FactoryBean是一个特殊bean: 自己 + 产生的bean * Spring能获取到该bean, 和该bean产生的bean */ public class DbMapperFactoryBean implements FactoryBean { Class mapperInterface; @Override public Object getObject() throws Exception { Object object = DbSession.getMapper(mapperInterface); return object; } @Override public Class getObjectType() { return mapperInterface; } } ImportBeanDefinitionRegistrar 注册FactoryBean到Spring中 package com.test.mybatis; import org.springframework.beans.factory.support.AbstractBeanDefinition; import org.springframework.beans.factory.support.BeanDefinitionBuilder; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.context.annotation.ImportBeanDefinitionRegistrar; import org.springframework.core.type.AnnotationMetadata; /** * @Author mubi * @Date 2020/7/11 13:45 * ImportBeanDefinitionRegistrar 动态的注册自己写的Bean, 这里是`DbMapperFactoryBean` */ public class DbImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(DbMapperFactoryBean.class); AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // 这里可以利用反射，for循环mapper package下的所有Mapper类，然后添加所有 beanDefinition.getConstructorArgumentValues() .addGenericArgumentValue(\"com.test.mapper.UserMapper\"); registry.registerBeanDefinition(\"dbMapperFactoryBean\", beanDefinition); } } 支持MapperScan注解 package com.test.mybatis; import org.springframework.context.annotation.Import; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) @Import(DbImportBeanDefinitionRegistrar.class) public @interface DbMapperScan{ } 测试 static void testSelfMybatis(){ UserMapper userMapper = (UserMapper) DbSession.getMapper(UserMapper.class); logger.info(\"selectTbUserById:\" + userMapper.selectUserById(1)); } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-26 20:19:04 "},"doc/springboot.html":{"url":"doc/springboot.html","title":"6 SpringBoot","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 SpringBoot 内嵌容器原理 零配置 SpringBoot spring web 官方文档 内嵌容器原理 零配置 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-26 19:40:06 "},"doc/bean/design.html":{"url":"doc/bean/design.html","title":"5.1 Spring中的设计模式","keywords":"","body":"Spring中用到了哪些设计模式？ Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-22 10:03:58 "},"doc/other/words.html":{"url":"doc/other/words.html","title":"5.1 单词","keywords":"","body":"单词 assemble v. 聚集; 集合; 收集; 装配; 组装; boilerplate n. (可供模仿的) 样板文件，文件范例; circular adj. 圆形的; 环形的; 圆的; 环行的; 绕圈的; 循环论证的(以一种观点证明另一观点，接着再用后一种观点反过来去证明前一观点); n. (同时送达很多人的)印刷信函(或通知、广告) ; customize vt. 定做，定制，按客户具体要求制造； Conceptual adj. 概念上的，观念上的 convey v. 表达，传递(思想、感情等); 传送; 运送; 输送; explicit adj. 清楚明白的; 易于理解的; (说话) 清晰的，明确的; 直言的; 坦率的; 直截了当的; 不隐晦的; 不含糊的; imperative adj. 必要的，不可避免的；紧急的；命令的，专横的；势在必行的；[语]祈使的 n. 必要的事；命令；需要；规则；[语]祈使语气 instantiate v. 例示；用具体例子说明; instantiation n. 实例化；[计] 例示 interdependency n. 互相依赖；相关性; invasive adj. 侵入的；入侵性的；扩散的 nested v. 筑巢; 巢居; 嵌套(信息); plug n. 插头；塞子；栓； vi. 塞住；用插头将与电源接通； vt. 插入；塞住；接插头 pluggability 可插性 propagation n. 传播; 扩展; 宣传; 培养; recipe n. 烹饪法; 食谱; 方法; 秘诀; 诀窍; scenario n. 设想; 方案; 预测; (电影或戏剧的) 剧情梗概; unresolvable 不能解决的 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-09 23:10:37 "}}