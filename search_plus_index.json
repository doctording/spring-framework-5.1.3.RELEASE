{"./":{"url":"./","title":"Introduction","keywords":"","body":"spring 源码实战阅读笔记 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-01 23:59:10 "},"doc/target.html":{"url":"doc/target.html","title":"前言","keywords":"","body":"学习目标 熟悉Spring原理 对各种Spring各种题能从容对答 借此熟悉各种设计模式，巩固各种Java基础知识 借此养成独立读英文文档,自己看源码并自主分析的能力 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-18 12:38:57 "},"doc/test/flow_path.html":{"url":"doc/test/flow_path.html","title":"2.1 ApplicationContext执行流程","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 测试代码执行流程 测试代码&xml 运行大致流程图 测试代码执行流程 测试代码&xml code 见：spring-framework-5.1.3.RELEASE/spring-context/src/test/java/test/com/mb/BeanTest.java @Test public void testClassPathXmlApplicationContextBeanCosr() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-constructor.xml\"); User user = (User) applicationContext.getBean(\"user\"); Assert.assertTrue(user != null); Assert.assertTrue(user.getTestStr().equals(\"testStr\")); Assert.assertTrue(user.getId().equals(1)); Assert.assertTrue(user.getName().equals(\"tom\")); } spring-constructor.xml 运行大致流程图 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-10-17 15:49:17 "},"doc/test/code_review.html":{"url":"doc/test/code_review.html","title":"2.2 执行流程:refresh的12个方法","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 ClassPathXmlApplicationContext & getBean ClassPathXmlApplicationContext构造函数执行 设置Environment环境变量和configLocations AbstractApplicationContext的refresh方法 prepareRefresh()先跳过 BeanFactory构造 抽象类AbstractXmlApplicationContext的loadBeanDefinitions方法 prepareBeanFactory(beanFactory) postProcessBeanFactory(beanFactory的postProcessor) registerBeanPostProcessors((bean的postProcessor)) initMessageSource & initApplicationEventMulticaster(消息和广播初始化) registerListeners()（注册监听器） finishBeanFactoryInitialization(beanFactory)（实例化操作） 抽象类AbstractAutowireCapableBeanFactory的doCreateBean方法 抽象类AbstractAutowireCapableBeanFactory的createBeanInstance方法 本例使用了无参的构造器return instantiateBean(beanName, mbd); BeanUtils的instantiateClass(ConstructorT ctor, Object... args)方法 反射:ctor.newInstance(args) finishRefresh() User user = (User) applicationContext.getBean(\"user\"); ClassPathXmlApplicationContext & getBean ClassPathXmlApplicationContext构造函数执行 附ClassPathXmlApplicationContext类的UML 测试例子使用的构造函数 public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); // 设置`this.configLocations` setConfigLocations(configLocations); if (refresh) { // 这里refresh为true（重点方法） // 这里使用了父类`AbstractApplicationContext`的`refresh`方法 refresh(); } } 设置Environment环境变量和configLocations AbstractApplicationContext的refresh方法 refresh方法概述了Ioc容器的处理流程 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // 从配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-> beanDefinition 的 map) // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); // 先看try里面做了哪些事情(读别的源码也一样，先主后次) try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // 执行程序员提供的BeanFactoryPostProcessor // 扫描类（当然@Configuration全注解类是直接先注册的，再根据这个@Configuration类完成扫描） // 此方法执行完成后，beanDefinitionMap就有了 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 单例bean的实例化（走单例bean的生命周期） finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } prepareRefresh()先跳过 BeanFactory构造 构造生成ConfigurableListableBeanFactory类型的BeanFactory refresh方法中构造beanFactory具体是DefaultListableBeanFactory(即注解方式所谓的BeanFactory就是DefaultListableBeanFactory)，调用了抽象类AbstractRefreshableApplicationContext的refreshBeanFactory方法 @Override protected final void refreshBeanFactory() throws BeansException { // 如果BeanFactory不为空，则清除BeanFactory里面的实例，并销毁BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // BeanFactory的实例工厂：DefaultListableBeanFactory DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); // 设置是否可以同名覆盖，循环依赖 customizeBeanFactory(beanFactory); // 解析比如xml文件，并把xml文件中的标签封装成BeanDefinition对象，加载到工厂中, 通常是通过代理读取器实现 // 比如 通过 XmlBeanDefinitionReader 读取 ClassPathXmlApplicationContext中传入的 configResources xml【模板设计】 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); } } 抽象类AbstractXmlApplicationContext的loadBeanDefinitions方法 BeanFactory实例工厂完成解析xml文件中的Bean并封装成BeanDefinition加载到工厂中 DefaultListableBeanFactory存储了BeanDefinition /** Map of bean definition objects, keyed by bean name. */ private final Map beanDefinitionMap = new ConcurrentHashMap<>(256); 附DefaultListableBeanFactoryUML（DefaultListableBeanFactory就是一个独立的Ioc容器） 有了beanFactory,要使用之，还要做各种工作，回到refresh方法 prepareBeanFactory(beanFactory) /** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */ protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 设置类加载器（要实例化bean,就需要类加载器） // Tell the internal bean factory to use the context's class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); // 设置EL表达式解析器（Bean初始化完成后填充属性时会用到） beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // 设置属性注册解析器PropertyEditor beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // 注册各种系统环境的bean组件（environment，systemProperties，systemEnvironment） // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } } postProcessBeanFactory(beanFactory的postProcessor) 在所有的BeanDefinition加载完成之后，bean实例化之前执行 /** * Modify the application context's internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for registering special * BeanPostProcessors etc in certain ApplicationContext implementations. * @param beanFactory the bean factory used by the application context */ protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { } // TODO 测试 invokeBeanFactoryPostProcessors(beanFactory) /** * Instantiate and invoke all registered BeanFactoryPostProcessor beans, * respecting explicit order if given. * Must be called before singleton instantiation. */ protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { // 1.getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值 // 2.invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } registerBeanPostProcessors((bean的postProcessor)) /** * Instantiate and invoke all registered BeanPostProcessor beans, * respecting explicit order if given. * Must be called before any instantiation of application beans. */ protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this); } 注册前的BeanPostProcessor: ApplicationContextAwareProcessor ApplicationListenerDetector 且之前已经将所有BeanDefinition加入到BeanDefinitionMap中了(之前已经应用了BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor了) BeanPostProcessor是可以有优先级顺序的，注册的时候也是按照顺序；没有顺序，就是常规的BeanPostProcessor // Now, register all regular BeanPostProcessors. List nonOrderedPostProcessors = new ArrayList<>(); for (String ppName : nonOrderedPostProcessorNames) { BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) { internalPostProcessors.add(pp); } } registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); 可以看到是直接beanFactory.getBean将这些BeanPostProcessor给实例化出来，注册后 FullLifeInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor FullLifeBeanPostProcessor implements BeanPostProcessor FullLifeMergedBeanDefinitionPostProcessor implements MergedBeanDefinitionPostProcessor initMessageSource & initApplicationEventMulticaster(消息和广播初始化) // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); 消息处理 & 事件监听 Initialize other special beans in specific context subclasses. onRefresh() /** * Template method which can be overridden to add context-specific refresh work. * Called on initialization of special beans, before instantiation of singletons. * This implementation is empty. * @throws BeansException in case of errors * @see #refresh() */ protected void onRefresh() throws BeansException { // For subclasses: do nothing by default. } registerListeners()（注册监听器） /** * Add beans that implement ApplicationListener as listeners. * Doesn't affect other listeners, which can be added without being beans. */ protected void registerListeners() { // 注册特殊的监听器 // Register statically specified listeners first. for (ApplicationListener listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // 取到所有监听器的名称，设置到上文初始化的广播器 // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); } // 如果存在早期应用事件，发布 // Publish early application events now that we finally have a multicaster... Set earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (earlyEventsToProcess != null) { for (ApplicationEvent earlyEvent : earlyEventsToProcess) { getApplicationEventMulticaster().multicastEvent(earlyEvent); } } } finishBeanFactoryInitialization(beanFactory)（实例化操作） 创建所有非懒加载的单例类（并invoke BeanPostProcessors） Bean循环依赖，AOP，生命周期回调等 抽象类AbstractAutowireCapableBeanFactory的doCreateBean方法 /** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */ protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { 抽象类AbstractAutowireCapableBeanFactory的createBeanInstance方法 /** * Create a new instance for the specified bean, using an appropriate instantiation strategy: * factory method, constructor autowiring, or simple instantiation. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a BeanWrapper for the new instance * @see #obtainFromSupplier * @see #instantiateUsingFactoryMethod * @see #autowireConstructor * @see #instantiateBean */ protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { 本例使用了无参的构造器return instantiateBean(beanName, mbd); /** * Instantiate the given bean using its default constructor. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @return a BeanWrapper for the new instance */ protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { try { Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) { beanInstance = AccessController.doPrivileged((PrivilegedAction) () -> getInstantiationStrategy().instantiate(mbd, beanName, parent), getAccessControlContext()); } else { beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); } BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; } catch (Throwable ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex); } } BeanUtils的instantiateClass(Constructor ctor, Object... args)方法 /** * Convenience method to instantiate a class using the given constructor. * Note that this method tries to set the constructor accessible if given a * non-accessible (that is, non-public) constructor, and supports Kotlin classes * with optional parameters and default values. * @param ctor the constructor to instantiate * @param args the constructor arguments to apply (use {@code null} for an unspecified * parameter if needed for Kotlin classes with optional parameters and default values) * @return the new instance * @throws BeanInstantiationException if the bean cannot be instantiated * @see Constructor#newInstance */ public static T instantiateClass(Constructor ctor, Object... args) throws BeanInstantiationException { Assert.notNull(ctor, \"Constructor must not be null\"); try { ReflectionUtils.makeAccessible(ctor); return (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ? KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args)); } catch (InstantiationException ex) { throw new BeanInstantiationException(ctor, \"Is it an abstract class?\", ex); } catch (IllegalAccessException ex) { throw new BeanInstantiationException(ctor, \"Is the constructor accessible?\", ex); } catch (IllegalArgumentException ex) { throw new BeanInstantiationException(ctor, \"Illegal arguments for constructor\", ex); } catch (InvocationTargetException ex) { throw new BeanInstantiationException(ctor, \"Constructor threw exception\", ex.getTargetException()); } } 反射:ctor.newInstance(args) 实例通过反射new出来了；反射相关知识参考：Java反射机制 finishRefresh() /** * Finish the refresh of this context, invoking the LifecycleProcessor's * onRefresh() method and publishing the * {@link org.springframework.context.event.ContextRefreshedEvent}. */ protected void finishRefresh() { // Clear context-level resource caches (such as ASM metadata from scanning). clearResourceCaches(); // Initialize lifecycle processor for this context. initLifecycleProcessor(); // Propagate refresh to lifecycle processor first. getLifecycleProcessor().onRefresh(); // Publish the final event. publishEvent(new ContextRefreshedEvent(this)); // Participate in LiveBeansView MBean, if active. LiveBeansView.registerApplicationContext(this); } User user = (User) applicationContext.getBean(\"user\"); AbstractBeanFactory的doGetBean方法 protected T doGetBean(final String name, @Nullable final Class requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { doGetBean走到org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean 第一步是创建BeanWrapper： 推断构造方法，然后反射实例化出来 这里要应用SmartInstantiationAwareBeanPostProcessor，比如AutowiredAnnotationBeanPostProcessor就是一个具体实现类 接着会对BeanWrapper执行applyMergedBeanDefinitionPostProcessors 显然，这里要应用MergedBeanDefinitionPostProcessor 然后是判断是否能循环依赖，有循环依赖需要暴露工厂 // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 判断是否允许循环依赖 boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); } // 即添加缓存 // BeanPostProcessor判断是否AOP（第4次调用BeanPostProcessor） // 提前暴露一个bean工厂 addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } 这里getEarlyBeanReference要应用SmartInstantiationAwareBeanPostProcessor，比如抽象类AbstractAutoProxyCreator（其实现类：AnnotationAwareAspectJAutoProxyCreator,AspectJAwareAdvisorAutoProxyCreator等） 接着是populateBean(beanName, mbd, instanceWrapper); 这里会应用InstantiationAwareBeanPostProcessor(先调用postProcessAfterInstantiation，然后postProcessProperties), 字段自动注入也在这里实现 最后是initializeBean(beanName, exposedObject, mbd); initializeBean首先是invokeAwareMethods（BeanNameAware，BeanClassLoaderAware，BeanFactoryAware） 然后applyBeanPostProcessorsBeforeInitialization,应用所有BeanPostProcessor的postProcessBeforeInitialization方法 接着invokeInitMethods(beanName, wrappedBean, mbd);（生命周期初始化方法） 最后applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);,即应用所有BeanPostProcessor的postProcessAfterInitialization,支持完成AOP，得到最后的\"成品\"bean 至此完成doCreate方法，将\"成品\"bean加入单例池 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-01-01 00:31:51 "},"doc/test/bean_constructor.html":{"url":"doc/test/bean_constructor.html","title":"2.3 bean & constructor-arg测试","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 bean & constructor-arg 测试代码&xml 流程关键点说明 构造BeanFactory(loadBeanDefinitions(beanFactory)会加载好构造参数) doGetBean方法读取BeanDefinition会读取到构造参数 在构造的时候会根据beanDefinition选择构造方法 最后使用BeanUtils实例化的时候会带上参数 bean & constructor-arg 主要说下跟默认构造函数构造bean的区别之处 测试代码&xml code 见：spring-framework-5.1.3.RELEASE/spring-context/src/test/java/test/com/mb/BeanTest.java @Test public void testClassPathXmlApplicationContextBean() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); User user = (User) applicationContext.getBean(\"user\"); Assert.assertTrue(user != null); Assert.assertTrue(user.getTestStr().equals(\"testStr\")); } spring.xml 流程关键点说明 构造BeanFactory(loadBeanDefinitions(beanFactory)会加载好构造参数) doGetBean方法读取BeanDefinition会读取到构造参数 在构造的时候会根据beanDefinition选择构造方法 最后使用BeanUtils实例化的时候会带上参数 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-20 10:00:06 "},"doc/bean/ioc_bean.html":{"url":"doc/bean/ioc_bean.html","title":"Ioc & BeanDefinition","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 IoC 容器 & Bean Spring处理流程简图 IoC(Inversion of Control) Container Ioc是什么？有什么用？为什么要Ioc? 为什么要有Ioc? Ioc容器的理解？ Ioc容器的实现机制？ IoC和DI的区别是什么？ Bean BeanDefinition 包括那些内容？ BeanDefinition的理解 Spring框架支持以下5种bean的作用域 自定义/定制化beanDefinition：AbstractBeanDefinition，GenericBeanDefinition等 Dependency Injection 回答：有哪些不同类型的IOC（依赖注入）方式？两种注入方式 IoC 容器 & Bean Spring处理流程简图 附：spring docs IoC(Inversion of Control) Container The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects. ApplicationContext这个接口就代表IoC容器，它负责实例化、配置和组装bean。容器通过读取配置文件的元数据来获取要实例化、配置和组装哪些对象的指令。配置文件支持xml,Java注解和纯Java代码。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。 Ioc是什么？有什么用？为什么要Ioc? Spring通过DI(dependency injection依赖注入)来实现Ioc，把对象的实例化过程的控制权给到了容器(即Spring容器)：以前创建一个对象都是程序员自己控制new出来的，现在是容器来决定产生时机和使用哪个构造方法(Spring源码中有通过BeanPostProcessor来推断构造方法的) 对象怎么创建？ new 工厂 反射 那么是随便什么对象都是由容器创建的吗？显然不是，必须是定义成bean的？ BeanDefinition 为什么要有Ioc? 传统开发中，类与类之间是有依赖关系的，耦合性强；要面向抽象编程，借助\"第三方\"实现具有依赖关系的对象之间的解耦 Ioc容器的理解？ 代码级别理解：容器可以理解为ApplicationContext对象，一切ApplicationContext的实现类都能成为容器 理论角度：容器是由很多Spring组件一起构成的，比如beanDefinitionMap, 单例池，beanFactory，各种PostProcessor Ioc容器的实现机制？ 关键技术点：简单工厂 + 反射 import org.apache.hadoop.util.hash.Hash; import java.util.HashMap; import java.util.Map; interface BaseOutService{ void drive(); } class CarServiceImpl implements BaseOutService{ @Override public void drive() { System.out.println(\"car drive\"); } } class PlaneServiceImpl implements BaseOutService{ @Override public void drive() { System.out.println(\"plane drive\"); } } class TrainServiceImpl implements BaseOutService{ @Override public void drive() { System.out.println(\"train drive\"); } } class Factory { Map beanMap; public Factory(){ beanMap = new HashMap(); } public void addBeanDefinition(String beanName, String className){ beanMap.put(beanName, className); } public BaseOutService getBean(String beanName) { BaseOutService baseService = null; String className = beanMap.get(beanName); try { Class clz = Class.forName(className); Object o = clz.newInstance(); baseService = (BaseOutService) o; } catch (Exception e) { } return baseService; } } public class Solution { public static void main(String[] args) throws InterruptedException { Factory factory = new Factory(); factory.addBeanDefinition(\"car\", \"com.CarServiceImpl\"); factory.addBeanDefinition(\"plane\", \"com.PlaneServiceImpl\"); BaseOutService carService = factory.getBean(\"car\"); carService.drive(); BaseOutService planeService = factory.getBean(\"plane\"); planeService.drive(); factory.addBeanDefinition(\"train\", \"com.TrainServiceImpl\"); BaseOutService trainService = factory.getBean(\"train\"); trainService.drive(); } } 如上，使用简单工厂加上反射：要实现一个BaseOutService，则只需要添加一个BeanDefinition到工厂中，然后就能从工厂获取这个bean了 IoC和DI的区别是什么？ IoC：控制反转，控制对象创建的产生方式：不是自己new，而是交给容器，让容器维护对象间的对象关系（一种设计思想，解决耦合问题） DI: 依赖注入，实现了IoC；是IoC实现的重要一环 Bean In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container. 在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是一个由Spring IoC容器实例化、组装和管理的对象。 Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata: 在容器内部，这些bean定义表示为BeanDefinition对象，包含着以下元数据： A package-qualified class name: typically, the actual implementation class of the bean being defined.（全限定类名） Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).（Bean的行为配置元素，作用域，生命周期回调等） References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.（对该bean执行其工作所需的其它bean的引用。） Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.（在创建bean对象时的其他配置，如连接池的最大数量） BeanDefinition 包括那些内容？ 属性 说明 Class 类 Name 名称 Scope bean作用域 Constructor arguments 构造器参数 Properties 成员属性 Autowiring mode 自动装配模式(是否自动装配的候选，是否主要的候选) Lazy initialization mode 懒加载模式 initialization method 初始化方法 Destruction methods 销毁方法 BeanDefinition的理解 普通Java对象的产生 假设磁盘上有N个.java文件，首先我们把这些java文件编译成class文件，继而java虚拟机启动会把这些class文件load到内存，当遇到new关键字的时候会根据类的模板信息实例化这个对象，即在堆上分配内存生成对象 spring的bean实例化过程 当spring容器启动的时候会去调用ConfigurationClassPostProcessor这个bean工厂的后置处理器完成扫描(把类的信息读取到，但是读取到类的信息存放起来) ---> beanDefinition 每扫描到一个符合规则的类，spring都会实例化一个BeanDefinition对象，然后把根据类的类名生成一个bean的名字（当然程序员可以自定义） beanDefinitionMap 存放所有的bean 可以有自定义的BeanFactoryPostProcessor（这里注意不同的 BeanFactoryPostProcessor 执行时机不同，BeanDefinitionRegistryPostProcessor先于BeanFactoryPostProcessor） 根据 BeanDefinition 完成实例化（注意 Bean 实例化也仅仅只需要 BeanDefinition） Spring框架支持以下5种bean的作用域 singleton：bean在每个Spring ioc 容器中只有一个实例，即常说的单例bean prototype：一个bean的定义可以有多个实例。 request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 缺省的Spring bean的作用域是singleton. 自定义/定制化beanDefinition：AbstractBeanDefinition，GenericBeanDefinition等 AbstractBeanDefinition(模板) RootBeanDefinition: 作为父beanDefinition,真实beanDefinition ChildBeanDefinition：能够继承父beanDefinition GenericBeanDefinition AnnotatedBeanDefinition ConfigurationClassBeanDefinition ScannedGenericBeanDefinition Dependency Injection DI主要是两类变形：Constructor-based Dependency Injection & Setter-based Dependency Injection Constructor-based Dependency Injection Setter-based Dependency Injection 回答：有哪些不同类型的IOC（依赖注入）方式？两种注入方式 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 // 1. 构造方法参数 // 2. set属性 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-10-24 12:59:15 "},"doc/bean/BeanFactory.html":{"url":"doc/bean/BeanFactory.html","title":"BeanFactory","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 BeanFactory 定义和类图 BeanFactory 定义和类图 spring docs of BeanFactory The root interface for accessing a Spring bean container. BeanFactory 是 Spring bean容器的最顶层的interface This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. \"request\" and \"session\" scopes in a web environment). BeanFactory的实现类即具体的容器，拥有一系列bean的定义，并实现这些基础方法，能返回bean的对象实例 The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of \"Expert One-on-One J2EE Design and Development\" for a discussion of the benefits of this approach. BeanFactory是应用程序组件的注册器，统一管理 Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection). BeanFactory负责加载bean,并能返回Java对象实例，并最好能支持Bean之间的引用关系 Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. BeanFactory要尽可能的实现Bean的生命周期接口 Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is: BeanNameAware's setBeanName BeanClassLoaderAware's setBeanClassLoader BeanFactoryAware's setBeanFactory EnvironmentAware's setEnvironment EmbeddedValueResolverAware's setEmbeddedValueResolver ResourceLoaderAware's setResourceLoader (only applicable when running in an application context) ApplicationEventPublisherAware's setApplicationEventPublisher (only applicable when running in an application context) MessageSourceAware's setMessageSource (only applicable when running in an application context) ApplicationContextAware's setApplicationContext (only applicable when running in an application context) ServletContextAware's setServletContext (only applicable when running in a web application context) postProcessBeforeInitialization methods of BeanPostProcessors InitializingBean's afterPropertiesSet a custom init-method definition postProcessAfterInitialization methods of BeanPostProcessors On shutdown of a bean factory, the following lifecycle methods apply: postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors DisposableBean's destroy a custom destroy-method definition Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-30 11:04:21 "},"doc/bean/context.html":{"url":"doc/bean/context.html","title":"BeanFactory & ApplicationContext","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 BeanFactory & ApplicationContext BeanFactory BeanFactoryPostProcessor的理解? ApplicationContext & BeanFactory 的区别和联系 附：国际化是什么？ ClassPathXmlApplicationContext举例 BeanFactory & ApplicationContext BeanFactory 负责配置、创建、管理Bean；IOC功能的实现主要就依赖于该接口子类实现；详见对beanFactory的介绍 BeanFactoryPostProcessor的理解? BeanFactoryPostProcessor是Spring中提供的一个扩展点 Spring源码中ConfigurationClassPostProcessor，它就是一个BeanFactory的后置处理器，它负责解析配置类，完成扫描，把扫描得到的BeanDefinition注册到BeanFactory中 ApplicationContext & BeanFactory 的区别和联系 ApplicationContext和BeanFactory一样都是bean容器 BeanFactory是一切Bean容器的父类，是最顶层interface ApplicationContext继承了BeanFactory，ApplicationContext包含了BeanFactory的所有功能，并且扩展了其它功能 国际化（MessageSource） 访问资源，如URL和文件（ResourceLoader） 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 消息发送、响应机制（ApplicationEventPublisher） AOP（拦截器） ApplicationContext除了bean的管理配置相关的能力，ApplicationContext还拥有了Environment（环境）、MessageSource（国际化）、ResourceLoader（资源）、ApplicationEventPublisher（应用事件）等服务相关的接口，简单的说ApplicationContext是以bean管理为基础的综合能力扩展，用于满足业务对Spring综合能力的需要； 附：国际化是什么？ 应用程序运行时，可根据客户端操作系統的国家/地区、语言的不同而显示不同的界面，比如客户端OS的语言环境为大陆的简体中文，程序就显示为简体中文，客户端OS的语言环境为美国——英语，程序就显示美式英语。OS的语言环境可在控制面板中手动设置。国际化的英文单词是Internationalization，单词较长，通常简称i18n，I是第一个字母，18表示中间省略了18个字母，N是最后一个字母。 假设我们正在开发一个支持多国语言的Web应用程序，要求系统能够根据客户端的系统的语言类型返回对应的界面：英文的操作系统返回英文界面，而中文的操作系统则返回中文界面——这便是典型的i18n国际化问题。对于有国际化要求的应用系统，我们不能简单地采用硬编码的方式编写用户界面信息、报错信息等内容，而必须为这些需要国际化的信息进行特殊处理。简单来说，就是为每种语言提供一套相应的资源文件，并以规范化命名的方式保存在特定的目录中，由系统自动根据客户端语言选择适合的资源文件。 ClassPathXmlApplicationContext举例 解析配置的xml信息，将xml路径信息赋值给configLocations，设置了配置信息之后对ApplicationContext进行初始化操作（refresh方法） public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { //调用父类的构造函数 super(parent); //设置配置xml setConfigLocations(configLocations); //ApplicationContext初始化 if (refresh) { refresh(); } } refresh的12个方法 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. // 获取BeanFactory；默认实现是DefaultListableBeanFactory，在创建容器的时候创建的 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //对BeanFactory进行各种功能扩展 prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. //子类覆盖方法做额外的处理 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 激活各种BeanFactory处理器 // 会处理@PropertySources，@ComponentScan，@Import等注解 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. //注册拦截Bean创建对Bean处理器，这里只是注册，真正调用是在getBean对时候 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. //为上下文初始化Message initMessageSource(); // Initialize event multicaster for this context. //初始化应用消息广播器 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. //留给子类来初始化其它的Bean onRefresh(); // Check for listener beans and register them. //在所有注册对bean中寻找Listener bean，注册到消息广播器中 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. //初始化单例bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. //完成刷新过程，通知生命周期处理器刷新过程，同时发出ContextRefreshEvent通知别人 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-10-24 13:05:27 "},"doc/bean/context_event.html":{"url":"doc/bean/context_event.html","title":"事件发布和监听机制","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 事件发布和监听机制 事件类：ApplicationEvent abstract class ApplicationContextEvent 容器事件(事件源是ApplicationContext) class RequestHandledEvent extends ApplicationEvent 事件监听器接口（ApplicationListener） 例子 事件发布和监听机制 在一个完整的事件体系中，除了事件和监听器以外，还应该有3个概念； 事件源：事件的产生者，任何一个event都必须有一个事件源； 事件广播器：它是事件和事件监听器之间的桥梁，负责把事件通知给事件监听器； 事件监听器注册表：就是spring框架为所有的监听器提供了一个存放的地方； 事件类：ApplicationEvent ApplicationEvent唯一的构造函数是ApplicationEvent（Object source），通过source指定事件源 /** * Class to be extended by all application events. Abstract as it * doesn't make sense for generic events to be published directly. * * @author Rod Johnson * @author Juergen Hoeller */ public abstract class ApplicationEvent extends EventObject { /** use serialVersionUID from Spring 1.2 for interoperability. */ private static final long serialVersionUID = 7099057708183571937L; /** System time when the event happened. */ private final long timestamp; /** * Create a new ApplicationEvent. * @param source the object on which the event initially occurred (never {@code null}) */ public ApplicationEvent(Object source) { super(source); this.timestamp = System.currentTimeMillis(); } /** * Return the system time in milliseconds when the event happened. */ public final long getTimestamp() { return this.timestamp; } } abstract class ApplicationContextEvent 容器事件(事件源是ApplicationContext) public abstract class ApplicationContextEvent extends ApplicationEvent { /** * Create a new ContextStartedEvent. * @param source the {@code ApplicationContext} that the event is raised for * (must not be {@code null}) */ public ApplicationContextEvent(ApplicationContext source) { super(source); } /** * Get the {@code ApplicationContext} that the event was raised for. */ public final ApplicationContext getApplicationContext() { return (ApplicationContext) getSource(); } } class RequestHandledEvent extends ApplicationEvent 一个与Web应用相关的事件，当一个请求被处理后，才会产生该事件 public class RequestHandledEvent extends ApplicationEvent { /** Session id that applied to the request, if any. */ @Nullable private String sessionId; /** Usually the UserPrincipal. */ @Nullable private String userName; /** Request processing time. */ private final long processingTimeMillis; /** Cause of failure, if any. */ @Nullable private Throwable failureCause; /** * Create a new RequestHandledEvent with session information. * @param source the component that published the event * @param sessionId the id of the HTTP session, if any * @param userName the name of the user that was associated with the * request, if any (usually the UserPrincipal) * @param processingTimeMillis the processing time of the request in milliseconds */ public RequestHandledEvent(Object source, @Nullable String sessionId, @Nullable String userName, long processingTimeMillis) { super(source); this.sessionId = sessionId; this.userName = userName; this.processingTimeMillis = processingTimeMillis; } /** * Create a new RequestHandledEvent with session information. * @param source the component that published the event * @param sessionId the id of the HTTP session, if any * @param userName the name of the user that was associated with the * request, if any (usually the UserPrincipal) * @param processingTimeMillis the processing time of the request in milliseconds * @param failureCause the cause of failure, if any */ public RequestHandledEvent(Object source, @Nullable String sessionId, @Nullable String userName, long processingTimeMillis, @Nullable Throwable failureCause) { this(source, sessionId, userName, processingTimeMillis); this.failureCause = failureCause; } public long getProcessingTimeMillis() { return this.processingTimeMillis; } @Nullable public String getSessionId() { return this.sessionId; } @Nullable public String getUserName() { return this.userName; } public boolean wasFailure() { return (this.failureCause != null); } @Nullable public Throwable getFailureCause() { return this.failureCause; } public String getShortDescription() { StringBuilder sb = new StringBuilder(); sb.append(\"session=[\").append(this.sessionId).append(\"]; \"); sb.append(\"user=[\").append(this.userName).append(\"]; \"); return sb.toString(); } public String getDescription() { StringBuilder sb = new StringBuilder(); sb.append(\"session=[\").append(this.sessionId).append(\"]; \"); sb.append(\"user=[\").append(this.userName).append(\"]; \"); sb.append(\"time=[\").append(this.processingTimeMillis).append(\"ms]; \"); sb.append(\"status=[\"); if (!wasFailure()) { sb.append(\"OK\"); } else { sb.append(\"failed: \").append(this.failureCause); } sb.append(']'); return sb.toString(); } @Override public String toString() { return (\"RequestHandledEvent: \" + getDescription()); } } 事件监听器接口（ApplicationListener） 监听器都需要实现该接口，该接口只定义了一个方法:onApplicationEvent (E event)，该方法接收事件对象，在该方法中编写事件的响应处理逻辑。 @FunctionalInterface public interface ApplicationListener extends EventListener { /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event); } 例子 具体事件，继承ApplicationContextEvent public class MailSendEvent extends ApplicationContextEvent { private static final long serialVersionUID = 1L; private String to; //目的地 public MailSendEvent(ApplicationContext source, String to) { super(source); this.to = to; } public String getTo(){ return this.to; } } 构造事件实例，并发送事件 实现了ApplicationContextAware能获取到ApplicationContext，则能进行事件的发布 @Component public class MailSender implements ApplicationContextAware { @Autowired private ApplicationContext applicationContext; // 容器事件由容器触发 public void sendMail(String to){ System.out.println(\"...ApplicationContextAware\"); MailSendEvent event = new MailSendEvent(applicationContext, to); applicationContext.publishEvent(event); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } } 监听到具体事件 @Component public class MailSendListener implements ApplicationListener { @Override public void onApplicationEvent(MailSendEvent mailSendEvent) { System.out.println(\"...onApplicationEvent\"); MailSendEvent event = mailSendEvent; System.out.println(\"MailSender向\"+ event.getTo()+ \"发送了邮件\"); } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-11 10:49:12 "},"doc/bean/bean_life.html":{"url":"doc/bean/bean_life.html","title":"Bean生命周期&回调","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 bean的生命周期？ 单例Bean生命周期图解 bean个性化定制：生命周期回调 bean个性化定制：ApplicationContextAware，BeanNameAware等 ApplicationContextAware 例子 Aware接口 Aware的执行 bean的生命周期？ 以如下测试代码为例 @Test public void testClassPathXmlApplicationContextBean() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-full-life.xml\"); System.out.println(\"----------------applicationContext\"); FullBean fullBean = (FullBean)applicationContext.getBean(\"fullBean\"); System.out.println(\"fullBean.getName:\" + fullBean.getName()); ((ClassPathXmlApplicationContext) applicationContext).close(); } 其中单例fullBean依赖了单例fullBeanB且配置了相关初始化，销毁方法，和BeanPostProcessor bean生命周期代码流程 ClassPathXmlApplicationContext doGetBean(InstantiationAwareBeanPostProcessor doGetBean(BeanPostProcessor doGetBean(fullBean dependsOn createBean resolveBeforeInstantiation applyBeanPostProcessorsBeforeInstantiation（应用所有的InstantiationAwareBeanPostProcessor） postProcessBeforeInstantiation doCreateBean createBeanInstance(推断构造方法，反射创建一个对象) populateBean(设置属性，其中依赖Bean 要走 依赖bean的创建逻辑) InstantiationAwareBeanPostProcessor：postProcessAfterInstantiation applyPropertyValues(beanName, mbd, bw, pvs); initializeBean applyBeanPostProcessorsBeforeInitialization（应用所有的BeanPostProcessor） postProcessBeforeInitialization invokeInitMethods InitializingBean(afterPropertiesSet) InitMethod 加入单例池 fullBean.getName ( bean的使用) ((ClassPathXmlApplicationContext) applicationContext).close() doClose Publish shutdown event. lifecycleProcessor.onClose(); destroyBeans DisposableBean destroy-method closeBeanFactory onClose() this.active.set(false); Runtime.getRuntime().removeShutdownHook(this.shutdownHook); 单例Bean生命周期图解 bean个性化定制：生命周期回调 bean生命周期干预 Initialization Callbacks Destruction Callbacks Default Initialization and Destroy Methods Combining Lifecycle Mechanisms Startup and Shutdown Callbacks Shutting Down the Spring IoC Container Gracefully in Non-Web Applications 关键词： InitializingBean DisposableBean @PostConstruct @PreDestroy BeanPostProcessor bean个性化定制：ApplicationContextAware，BeanNameAware等 ApplicationContextAware 例子 @Component public class CommandManager implements ApplicationContextAware { private ApplicationContext applicationContext; public CommandManager() { System.out.println(\"CommandManager construct\"); } /** * CommandManager 需要一个依赖一个 `@Scope(\"prototype\")`的 Command Bean, 但是自身又是 单例Bean * 通过实现 ApplicationContextAware, 能获取到 CommandManager 所在的 ApplicationContext，然后再据此获取原型 Command Bean */ public String process(int commandState) { // grab a new instance of the appropriate Command Command command = createCommand(); System.out.println(\"command:\" + command); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); } protected Command createCommand() { // notice the Spring API dependency! return this.applicationContext.getBean(\"command\", Command.class); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } } Aware接口 所有的Aware接口都是为了能让我们能拿到容器中相关的资源 回顾bean生命周期主要的三个步骤 createBeanInstance, 创建实例 populateBean, 属性注入（循环依赖完成） initializeBean, 初始化 在其中initializeBean会完成Aware接口方法的执行，源码如下 protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged((PrivilegedAction) () -> { invokeAwareMethods(beanName, bean); return null; }, getAccessControlContext()); } else { // 第一步：执行aware接口中的方法，需要主要的是，不是所有的Aware接口都是在这步执行了 invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // 第二步：完成Aware接口方法的执行,以及@PostConstructor,@PreDestroy注解的处理 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // 第三步：完成初始化方法执行 invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); } if (mbd == null || !mbd.isSynthetic()) { // 第四步：完成AOP代理 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean; } Aware的执行 先完成BeanNameAware，BeanClassLoaderAware，BeanFactoryAware的执行 BeanNameAware：获取Bean的名字 BeanClassLoaderAware：获取加载这个Bean的类加载器 BeanFactoryAware：获取当前的BeanFactory private void invokeAwareMethods(final String beanName, final Object bean) { if (bean instanceof Aware) { if (bean instanceof BeanNameAware) { ((BeanNameAware) bean).setBeanName(beanName); } if (bean instanceof BeanClassLoaderAware) { ClassLoader bcl = getBeanClassLoader(); if (bcl != null) { ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); } } if (bean instanceof BeanFactoryAware) { ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); } } } 接着完成Aware其它接口方法的执行，以及@PostConstructor,@PreDestroy注解的处理 protected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd) throws Throwable { // 是否实现了 InitializingBean接口 boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean && (mbd == null || // 这个判断基本恒成立，除非手动改变了BD的属性 !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) { if (logger.isTraceEnabled()) { logger.trace(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\"); } if (System.getSecurityManager() != null) { try { AccessController.doPrivileged((PrivilegedExceptionAction) () -> { // 调用afterPropertiesSet方法 ((InitializingBean) bean).afterPropertiesSet(); return null; }, getAccessControlContext()); } catch (PrivilegedActionException pae) { throw pae.getException(); } } else { // 调用afterPropertiesSet方法 ((InitializingBean) bean).afterPropertiesSet(); } } if (mbd != null && bean.getClass() != NullBean.class) { String initMethodName = mbd.getInitMethodName(); if (StringUtils.hasLength(initMethodName) && !(isInitializingBean && \"afterPropertiesSet\".equals(initMethodName)) && !mbd.isExternallyManagedInitMethod(initMethodName)) { invokeCustomInitMethod(beanName, bean, mbd); } } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-16 19:43:01 "},"doc/bean/bean_scope.html":{"url":"doc/bean/bean_scope.html","title":"Bean的作用域","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Bean Scope Spring bean 的默认作用范围是什么？ Spring 中的 singleton bean 的线程安全问题？ prototype Bean Scope bean scope doc scope description - singletion (Default) Scopes a single bean definition to a single object instance per Spring IoC container. 单例bean prototype Scopes a single bean definition to any number of object instances. 多例bean,每次请求都新产生bean request Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效 session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效 application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. - websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. - Spring bean 的默认作用范围是什么？ singletion Spring 中的 singleton bean 的线程安全问题？ 存在线程问题; 对于一个无状态Bean(即对bean属，性只有读操作，无写操作)，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。 对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。 prototype Spring does not manage the complete lifecycle of a prototype bean @Component(\"userService\") @Scope(\"prototype\") public class UserServiceImpl implements UserService { @Autowired private UserRepo userRepo; @Override public User getUserById(Integer id){ User user = userRepo.getById(id); try { TimeUnit.SECONDS.sleep(2); } catch (Exception e) { e.printStackTrace(); } return user; } } AbstractBeanFactory类的doGetBean方法 else if (mbd.isPrototype()) { // It's a prototype -> create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } 总结：多线程, 生成多个实例，Ioc容器不负责完整的生命周期 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-07 23:25:20 "},"doc/bean/fatory_bean.html":{"url":"doc/bean/fatory_bean.html","title":"FactoryBean接口","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 FactoryBean FactoryBean 官方文档阅读 FactoryBean 实践 面试题：FactoryBean跟BeanFactory的区别？ FactoryBean Customizing Instantiation Logic with a FactoryBean FactoryBean 官方文档阅读 功能：使用FactoryBean定制bean的实例化逻辑 The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex initialization inside that class, and then plug your custom FactoryBean into the container. The FactoryBean interface provides three methods: Object getObject(): Returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes. boolean isSingleton(): Returns true if this FactoryBean returns singletons or false otherwise. Class getObjectType(): Returns the object type returned by the getObject() method or null if the type is not known in advance. 首先FactoryBean它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。 FactoryBean 实践 实现一个FactoryBean import org.springframework.beans.factory.FactoryBean; /** * @Author mubi * @Date 2020/7/4 13:01 */ public class MyGoFactoryBean implements FactoryBean { private String type; private Go getDefaultGo(){ return new Go() { @Override public void out() { System.out.println(\"just go on foot\"); } }; } public String getType() { return type; } public void setType(String type) { this.type = type; } @Override public Go getObject(){ if (type == null) { return getDefaultGo(); } if (type.equalsIgnoreCase(GoEnum.BIKE.getType())) { return new BikeGo(); } if (type.equalsIgnoreCase(GoEnum.CAR.getType())) { return new CarGo(); } return getDefaultGo(); } @Override public Class getObjectType() { return Go.class ; } @Override public boolean isSingleton() { return false; } } GoEnum public enum GoEnum { BIKE(\"bike\"), CAR(\"car\"); String type; GoEnum(String type) { this.type = type; } public String getType() { return type; } } xml中定制bean 测试 @Test public void testDependencySpring() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-factory-bean.xml\"); Go go = (Go) applicationContext.getBean(\"go\"); go.out(); } 面试题：FactoryBean跟BeanFactory的区别？ 怎么回答？ FactoryBean是Spring提供的一个扩展点，适用于复杂的Bean的创建，比如Mybatis在跟Spring做整合时就用到了这个扩展点。并且FactoryBean所创建的Bean跟普通的Bean不一样。我们可以说FactoryBean是Spring创建Bean的另外一种手段。 BeanFactory是Spring IOC容器的顶级接口，其实现类有XMLBeanFactory，DefaultListableBeanFactory以及AnnotationConfigApplicationContext等。BeanFactory为Spring管理Bean提供了一套通用的规范 boolean containsBean(String beanName) Object getBean(String) Object getBean(String, Class) Class getType(String name) boolean isSingleton(String) String[] getAliases(String name) 通过这些方法，可以方便地获取bean，对Bean进行操作和判断 FactoryBean是一个能生产或修饰对象生成的工厂Bean。一个Bean如果实现了FactoryBean接口，那么根据该Bean的名称获取到的实际上是getObject()返回的对象，而不是这个Bean自身实例，如果要获取这个Bean自身实例，那么需要在名称前面加上&符号。 @Component public class MyBean implements FactoryBean { private String message; public MyBean() { this.message = \"通过构造方法初始化实例\"; } @Override public Object getObject() throws Exception { MyBean myBean = new MyBean(); myBean.message = \"通过FactoryBean.getObject()创建实例\"; // 这里并不一定要返回MyBean自身的实例，可以是其他任何对象的实例 return myBean; } @Override public Class getObjectType() { return MyBean.class; } public String getMessage() { return message; } } @RunWith(SpringRunner.class) @SpringBootTest(classes = TestApplication.class) public class FactoryBeanTest { @Autowired private ApplicationContext context; @Test public void test() { MyBean myBean1 = (MyBean) context.getBean(\"myBean\"); System.out.println(\"myBean1 = \" + myBean1.getMessage()); MyBean myBean2 = (MyBean) context.getBean(\"&myBean\"); System.out.println(\"myBean2 = \" + myBean2.getMessage()); System.out.println(\"myBean1.equals(myBean2) = \" + myBean1.equals(myBean2)); } } 输出 myBean1 = 通过FactoryBean.getObject()初始化实例 myBean2 = 通过构造方法初始化实例 myBean1.equals(myBean2) = false Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-30 10:57:38 "},"doc/bean/lazy.html":{"url":"doc/bean/lazy.html","title":"懒加载bean","keywords":"","body":"懒加载bean refresh方法执行的finishBeanFactoryInitialization是实例化所有非懒加载的单例bean org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization /** * Finish the initialization of this context's bean factory, * initializing all remaining singleton beans. */ protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // Initialize conversion service for this context. if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) && beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) { beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); } // Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) { beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal)); } // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early. String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) { getBean(weaverAwareName); } // Stop using the temporary ClassLoader for type matching. beanFactory.setTempClassLoader(null); // Allow for caching all bean definition metadata, not expecting further changes. beanFactory.freezeConfiguration(); // Instantiate all remaining (non-lazy-init) singletons. beanFactory.preInstantiateSingletons(); } DefaultListableBeanFactory的preInstantiateSingletons方法 org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-11-22 15:43:46 "},"doc/bean/ioc_bean_dependency.html":{"url":"doc/bean/ioc_bean_dependency.html","title":"Bean 依赖","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Bean Dependencies 构造参数实现：Constructor-based Dependency Injection set方法设置：Setter-based Dependency Injection 使用 depends-on 懒加载：Lazy-initialized Beans 自动装配 方法注入：Method Injection Bean Dependencies https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-dependencies 构造参数实现：Constructor-based Dependency Injection public class SimpleMovieLister { // the SimpleMovieLister has a dependency on a MovieFinder private MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) { this.movieFinder = movieFinder; } // business logic that actually uses the injected MovieFinder is omitted... } set方法设置：Setter-based Dependency Injection public class SimpleMovieLister { // the SimpleMovieLister has a dependency on the MovieFinder private MovieFinder movieFinder; // a setter method so that the Spring container can inject a MovieFinder public void setMovieFinder(MovieFinder movieFinder) { this.movieFinder = movieFinder; } // business logic that actually uses the injected MovieFinder is omitted... } 使用 depends-on 懒加载：Lazy-initialized Beans 自动装配 方法注入：Method Injection https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-factory-method-injection In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed. A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean(\"B\") call to the container ask for (a typically new) bean B instance every time bean A needs it. 实现ApplicationContextAware package com.mb.methodinjection; import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.stereotype.Component; /** * @Author mubi * @Date 2020/11/4 15:18 */ @Component public class CommandManager implements ApplicationContextAware { private ApplicationContext applicationContext; public CommandManager() { System.out.println(\"CommandManager construct\"); } /** * CommandManager 需要一个依赖一个 `@Scope(\"prototype\")`的 Command Bean, 但是自身又是 单例Bean * 通过实现 ApplicationContextAware, 能获取到 CommandManager 所在的 ApplicationContext，然后再据此获取原型 Command Bean */ public String process(int commandState) { // grab a new instance of the appropriate Command Command command = createCommand(); System.out.println(\"command:\" + command); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); } protected Command createCommand() { // notice the Spring API dependency! return this.applicationContext.getBean(\"command\", Command.class); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-11-04 21:24:18 "},"doc/bean/dependency.html":{"url":"doc/bean/dependency.html","title":"Spring循环依赖具体执行流程","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 循环依赖 什么是依赖？ Spring中循环依赖场景 singleton bean 属性循环依赖无问题 单例Bean循环依赖理解图 三级缓存涉及要点说明 单例的三级缓存getSingleton方法 AbstractBeanFactory类的doGetBean方法 获取单例bean：DefaultSingletonBeanRegistry类的getSingleton方法主体逻辑 AbstractAutowireCapableBeanFactory类的doCreateBean方法 Debug过程中的要点与截图 为什么是三级缓存？ scope bean 循环依赖有问题？ 测试代码 异常栈 循环依赖 什么是依赖？ eg1 A -> B B -> A eg2 A -> B -> C -> A Spring中循环依赖场景 构造器的循环依赖(spring无法解决) field属性的循环依赖(spring能解决单例bean的属性循环依赖,且要是setter注入方式) singleton bean 属性循环依赖无问题 单例Bean循环依赖理解图 三级缓存涉及要点说明 public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { ... // 从上至下 分表代表这“三级缓存” //一级缓存，也就单例池 private final Map singletonObjects = new ConcurrentHashMap<>(256); // 二级缓存，早起暴露对象，存放原始的 bean 对象（尚未填充属性） private final Map earlySingletonObjects = new HashMap<>(16); // 三级缓存，Map，存放 beanFactory 对象，用于解决循环依赖 private final Map> singletonFactories = new HashMap<>(16); ... /** Names of beans that are currently in creation. */ // 这个缓存也十分重要：它表示bean创建过程中 // 它在Bean开始创建时存入，创建完成后会将其移出 private final Set singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16)); /** Names of beans that have already been created at least once. */ // 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复 // 至少被创建了一次的 都会放进这里 private final Set alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap<>(256)); 其中isSingletonCurrentlyInCreation()方法判断当前单例Bean是否正在创建中（在创建中的Bean是没有初始化完全的） /** * Return whether the specified singleton bean is currently in creation * (within the entire factory). * @param beanName the name of the bean */ public boolean isSingletonCurrentlyInCreation(String beanName) { return this.singletonsCurrentlyInCreation.contains(beanName); } 单例的三级缓存getSingleton方法 /** * Return the (raw) singleton object registered under the given name. * Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or {@code null} if none found */ @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null && allowEarlyReference) { ObjectFactory singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return singletonObject; } 从一级缓存中取，有则返回 a. bean是在创建中，b. 早期暴露对象有(即二级缓存有)，有则返回 a. 允许循环依赖，三级缓存有，则获取并加入到二级缓存，且从三级缓存移除掉 AbstractBeanFactory类的doGetBean方法 // Create bean instance. if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -> { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } 也是getSingleton方法，有个lambda表达式的createBean方法 获取单例bean：DefaultSingletonBeanRegistry类的getSingleton方法主体逻辑 /** * Return the (raw) singleton object registered under the given name, * creating and registering a new one if none registered yet. * @param beanName the name of the bean * @param singletonFactory the ObjectFactory to lazily create the singleton * with, if necessary * @return the registered singleton object */ public Object getSingleton(String beanName, ObjectFactory singletonFactory) { Assert.notNull(beanName, \"Bean name must not be null\"); synchronized (this.singletonObjects) { // 1. 先判断是否在一级缓存中 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, \"Singleton bean creation not allowed while singletons of this factory are in destruction \" + \"(Do not request a bean from a BeanFactory in a destroy method implementation!)\"); } if (logger.isDebugEnabled()) { logger.debug(\"Creating shared instance of singleton bean '\" + beanName + \"'\"); } // 2. 创建前加入到`singletonsCurrentlyInCreation`集合中, 表示正在创建中（ // 因为单例池没有，则必须要去创建的 beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) { this.suppressedExceptions = new LinkedHashSet<>(); } try { // 3. 执行lambda表达式的创建逻辑获取到单例bean，即执行`doCreateBean` singletonObject = singletonFactory.getObject(); newSingleton = true; } catch (IllegalStateException ex) { // Has the singleton object implicitly appeared in the meantime -> // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { throw ex; } } catch (BeanCreationException ex) { if (recordSuppressedExceptions) { for (Exception suppressedException : this.suppressedExceptions) { ex.addRelatedCause(suppressedException); } } throw ex; } finally { if (recordSuppressedExceptions) { this.suppressedExceptions = null; } // 4. 创建完成后从`singletonsCurrentlyInCreation`集合中移除 // 即遇到创建异常 或者 创建完成，都是非创建中状态 afterSingletonCreation(beanName); } if (newSingleton) { // 5. 加入到一级缓存中，且从二级，三级缓存移除 addSingleton(beanName, singletonObject); } } // 6. 返回最终完整实例化的bean return singletonObject; } } AbstractAutowireCapableBeanFactory类的doCreateBean方法 /** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */ protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 1. factoryBeanInstanceCache 没有则需要主动创建 instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = instanceWrapper.getWrappedInstance(); Class beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) { mbd.resolvedTargetType = beanType; } // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); } mbd.postProcessed = true; } } // 加入到三级缓存: 即添加 // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isTraceEnabled()) { logger.trace(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); } addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } // Initialize the bean instance. Object exposedObject = bean; try { // 2. 填充bean的属性:即这里要完成bean依赖处理 populateBean(beanName, mbd, instanceWrapper); // 3. bean的initialize, beanPostProcessor等 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } if (earlySingletonExposure) { // 获取到AOP之后的代理对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { // 如果提前暴露的对象和经过了完整的生命周期后的对象相等，那么把代理对象赋值给`exposedObject` if (exposedObject == bean) { exposedObject = earlySingletonReference; } // 如果提前暴露的对象和经过了完整的生命周期后的对象不相等 // allowRawInjectionDespiteWrapping 表示在循环依赖时 else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set actualDependentBeans = new LinkedHashSet<>(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); } } } } // Register bean as disposable. try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); } return exposedObject; } org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference /** * Resolve a reference to another bean in the factory. */ @Nullable private Object resolveReference(Object argName, RuntimeBeanReference ref) { try { Object bean; String refName = ref.getBeanName(); refName = String.valueOf(doEvaluate(refName)); if (ref.isToParent()) { if (this.beanFactory.getParentBeanFactory() == null) { throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, \"Can't resolve reference to bean '\" + refName + \"' in parent factory: no parent factory available\"); } bean = this.beanFactory.getParentBeanFactory().getBean(refName); } else { bean = this.beanFactory.getBean(refName); this.beanFactory.registerDependentBean(refName, this.beanName); } if (bean instanceof NullBean) { bean = null; } return bean; } catch (BeansException ex) { throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, \"Cannot resolve reference to bean '\" + ref.getBeanName() + \"' while setting \" + argName, ex); } } Debug过程中的要点与截图 a依赖b，执行到a的populateBean(\"b\", mbd, instanceWrapper)的时候，发现依赖B，要走getBean(\"b\")的逻辑 populateBean(\"b\", mbd, instanceWrapper)的时候，发现依赖了A，又要去getBean(\"a\")，这样执行到getSingleton方法，此时从三级缓存中能取到A 从三级缓存取到A之后,执行了lambda(bean A)的逻辑，删除三级缓存，并将bean A加入二级缓存（根据工厂就能对A进行各种操作，得到最后的A，这里称为早期的曝光对象），然后B的populateBean方法能正常返回 由于B拿到了提交曝光的A，这样B就正常的完成A依赖的设置，顺利完成自己的populateBean方法，进入自己的初始化方法 最后B实例化全部完成后，加入到单例缓存池(一级缓存)中 由于B实例化的完成；A的populateBean方法也就能正常完成，并继续自己的初始化，最后完成生命周期；在最后也加入到单例缓存池(一级缓存)中 为什么是三级缓存？ Bean生命周期 A class --- BeanDefinition new A(); // 原始对象 populateBean（依赖注入）--> 单例池中找B --> 找不到 --> 创建B initializeBean BeanPostProcessor 完成并添加到单例池中 Bean生命周期 B class --- BeanDefinition new B(); // 原始对象 populateBean（依赖注入）--> 单例池中找A --> 找不到 --> 三级缓存中能找到 --> lambda(A) --> 提前得到代理A initializeBean BeanPostProcessor 完成并添加到单例池中 按照如上，如果只有 一级缓存(单例池) 和 三级缓存（工厂lambda生产），能够解决A,B依赖问题，接着又来了个C(且依赖A)；如果按照上面B的逻辑，那么可以发现lambda(A)会再次被执行，这可能导致B，C执行后获取的代理A不一致,如下(C也执行工厂方法得到代理A) Bean生命周期 C class --- BeanDefinition new C(); // 原始对象 populateBean（依赖注入）--> 单例池中找A --> 找不到 --> 三级缓存中能找到 --> lambda(A) --> 提前得到代理A initializeBean BeanPostProcessor 完成并添加到单例池中 所以再来一个缓存, 将工厂产生的代理对象A也缓存起来，所以最后是三个缓存(且备注了其用途) singletonObjects: 单例池：单例对象实例化一次，缓存最后的代理bean成品 earlySingletonObjects: map：解决性能问题？B,C,D都依赖A,工厂产生是开销的,且是重复的工厂创建，显然可以缓存好，提高性能 singletonFactories: map：beanFactory能够任意操作bean，解决循环依赖(提前暴露工厂，产生代理bean，属性注入) 完成populateBean之前，产生工厂，工厂能够产生bean。为什么是工厂？ 答: 因为populateBean拿到的依赖bean是原始的，显然依赖注入要是最后的代理品，而工厂能够让bean升华这个bean，变成最后的代理类（因为populateBean之后会有代理行为） 参考：bilibili 子路老师 scope bean 循环依赖有问题？ 测试代码 @Test public void testDependencySpringPrototype() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-dependency-prototype.xml\"); A a = (A) applicationContext.getBean(\"a\"); B b = (B) applicationContext.getBean(\"b\"); Assert.assertTrue(a != null); Assert.assertTrue(b != null); } spring-dependency-prototype.xml 异常栈 constructor A() constructor B() org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'a' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'b' while setting bean property 'b'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'b' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'a' while setting bean property 'a'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:378) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:110) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1648) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1400) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:575) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1094) at test.com.mb.DependencyTest.testDependencySpringPrototype(DependencyTest.java:44) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'b' defined in class path resource [spring-dependency-prototype.xml]: Cannot resolve reference to bean 'a' while setting bean property 'a'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:378) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:110) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1648) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1400) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:575) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:338) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:367) ... 31 more Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:264) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:367) ... 39 more Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-14 19:24:04 "},"doc/bean/post_processor.html":{"url":"doc/bean/post_processor.html","title":"BeanFactoryPostProcessor & BeanDefinitionRegistryPostProcessor","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 BeanFactoryPostProcessor Spring 内置的 bean ConfigurationClassPostProcessor refresh 12个方法中的invokeBeanFactoryPostProcessors(beanFactory); BeanFactoryPostProcessor bean工厂后置处理器：干预beanFactory的工作流程（默认就是干预DefaultListableBeanFactory） BeanFactoryPostProcessor是个接口，可以被继承，从而实现更多的功能，比如BeanDefinitionRegistryPostProcessor public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor { /** * Modify the application context's internal bean definition registry after its * standard initialization. All regular bean definitions will have been loaded, * but no beans will have been instantiated yet. This allows for adding further * bean definitions before the next post-processing phase kicks in. * @param registry the bean definition registry used by the application context * @throws org.springframework.beans.BeansException in case of errors */ void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; } 其中一个实现类ConfigurationClassPostProcessor /** * {@link BeanFactoryPostProcessor} used for bootstrapping processing of * {@link Configuration @Configuration} classes. * * Registered by default when using {@code } or * {@code }. Otherwise, may be declared manually as * with any other BeanFactoryPostProcessor. * * This post processor is priority-ordered as it is important that any * {@link Bean} methods declared in {@code @Configuration} classes have * their corresponding bean definitions registered before any other * {@link BeanFactoryPostProcessor} executes. * * @author Chris Beams * @author Juergen Hoeller * @author Phillip Webb * @since 3.0 */ public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware { beanFactoryPostProcessor的作用 修改BeanDefinition 注册BeanDefinition cglib代理 其它更多的扩展功能 Spring 内置的 bean org.springframework.context.annotation.ConfigurationClassPostProcessor org.springframework.context.event.DefaultEventListenerFactory org.springframework.context.event.EventListenerMethodProcessor org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor org.springframework.context.annotation.CommonAnnotationBeanPostProcessor ConfigurationClassPostProcessor ConfigurationClassPostProcessor实现了很多接口, 两个重要接口 BeanDefinitionRegistryPostProcessor （继承了BeanFactoryPostProcessor） BeanFactoryPostProcessor 由于BeanDefinitionRegistryPostProcessor是继承了BeanFactoryPostProcessor所以也可以理解这是一个接口 refresh 12个方法中的invokeBeanFactoryPostProcessors(beanFactory); 显示遍历找到BeanDefinitionRegistryPostProcessor，目前就是一个ConfigurationClassPostProcessor，然后执行一次 执行到invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);前后beanDefinitionMap有变化 可以看到执行完：自动被扫描的bean和一个自定义的BeanFactoryPostProcessor加入进来了 源码中：currentRegistryProcessors（就是ConfigurationClassPostProcessor），然后执行了ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法，该方法就是BeanDefinitionRegistryPostProcessor接口方法 获取全注解类的bean(@Configuration), 当然有全注解类且之前已经加入到beanDefinitionMap中了，本例中就是postProcessorConfigLifebean 根据全注解类bean构造一个ConfigurationClassBeanDefinitionReader的reader直接读取到当次能读取到的bean加入到beanDefinitionMap中，显然第一次就是只能获取到indexService和selfBeanFactoryPostProcessor 在最后可以看到要去执行自定义的beanPostProcessor 可以看到这次执行的是BeanFactoryPostProcessor接口的postProcessBeanFactory方法 所以最后可以看到refresh的12个方法中的invokeBeanFactoryPostProcessors(beanFactory);执行完则完成了所有bean加入到了beanDefinitionMap中去了 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-30 09:20:50 "},"doc/bean/property.html":{"url":"doc/bean/property.html","title":"PropertyPlaceholderConfigurer","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 PropertyPlaceholderConfigurer 例子代码报错 追踪源码看报错 bfpp的顺序问题？ 执行到第一个placeholderConfigurer1找不到配置即报错？为什么不接着找placeholderConfigurer2 根据debug分析尝试修改ignoreUnresolvablePlaceholders=true 多个配置覆盖问题 跟踪源码解释 PropertyPlaceholderConfigurer PropertyPlaceholderConfigurer的类图如下，可以看到其也是一个BeanFactoryPostProcessor 例子代码报错 public static void main(String[] args) { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application.xml\"); UserBean userBean = (UserBean) applicationContext.getBean(\"userBean\"); System.out.println(userBean.getName()); } classpath:app1.properties classpath:app2.properties app1.properties #app.name=v1 app2.properties app.name=v2 注意到app1.properties是注释掉的，执行后报错如下 追踪源码看报错 当执行org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()时可以看到有2个bfpp，一个是placeholderConfigurer1，一个是placeholderConfigurer2,这里先执行的是placeholderConfigurer1 bfpp的顺序问题？ 回到：org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()的如下代码 // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List priorityOrderedPostProcessors = new ArrayList<>(); List orderedPostProcessorNames = new ArrayList<>(); List nonOrderedPostProcessorNames = new ArrayList<>(); for (String ppName : postProcessorNames) { if (processedBeans.contains(ppName)) { // skip - already processed in first phase above } else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } 且注意到PropertyPlaceholderConfigurer是实现了PriorityOrdered的,我们也配置了顺序 执行到第一个placeholderConfigurer1找不到配置即报错？为什么不接着找placeholderConfigurer2 执行org.springframework.beans.factory.config.PropertyResourceConfigurer#postProcessBeanFactory @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { try { Properties mergedProps = mergeProperties(); // Convert the merged properties, if necessary. convertProperties(mergedProps); // Let the subclass process the properties. processProperties(beanFactory, mergedProps); } catch (IOException ex) { throw new BeanInitializationException(\"Could not load properties\", ex); } } mergedProp获取为空，在processProperties(beanFactory, mergedProps);这句报错了,进入到方法内部报错如下 placeholderConfigurer1的BeanDefinitionVisitor在解析${app.name}报错找不到 继续debug下去可以看到最后的报错位置如下，注意到ignoreUnresolvablePlaceholders=false，即【不忽略解析错误】是false, 可以看到如果是true就不会抛出异常了 根据debug分析尝试修改ignoreUnresolvablePlaceholders=true classpath:app1.properties 重新运行且成功拿到了配置2的值 多个配置覆盖问题 经过上一个报错，就会有个疑问，如果配置有多个且争取，那么到底最后会是哪一个？ 实际执行是order更小的，即第一个bfpp能正常解析到的配置就是userBean的配置值 跟踪源码解释 placeholderConfigurer1正确执行后userBean的BeanDefinition已经正确赋值了${app.name}的值 当placeholderConfigurer2正确执行时：如下（可以理解为之前都解析好了，这次还解析个鬼） 附第一次解析对比：(如下，才是真正的解析) Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2022-05-17 23:51:55 "},"doc/bean/bean.html":{"url":"doc/bean/bean.html","title":"@Bean","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 @Bean注解 测试程序 源码流程 @Bean注解 测试程序 @Configuration public class AppConfig { @Bean(initMethod = \"init\") public UserManager userManager(){ UserManager userManager = new UserManager(\"wangwu\"); userManager.setUserName(\"zhangsan\"); return userManager; } } public class UserManager { String userName; public UserManager() { System.out.println(\"constructor UserManager():\" + userName); } public UserManager(String userName) { this.userName = userName; System.out.println(\"constructor UserManager(String):\" + userName); } public void init() { System.out.println(\"start init UserManager:\" + userName); } @Override public String toString() { return \"UserManager{\" + \"userName='\" + userName + '\\'' + '}'; } public void setUserName(String userName) { this.userName = userName; } } 测试 AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); UserManager userManager = (UserManager) ac.getBean(\"userManager\"); System.out.println(userManager); 输出: constructor UserManager(String):wangwu start init UserManager:zhangsan UserManager{userName='zhangsan'} 源码流程 1 new AnnotationConfigApplicationContext的时候会初始化添加一个ConfigurationClassPostProcessor 2 当执行ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法时会找到全注解类，手动注册全注解类的bean，其时一个cglib代理实现，同时会执行读取器中的@Bean注解，完成userManagerBeanDefinition的注册 3 refresh方法走到finishBeanFactoryInitialization(beanFactory);doCreateBean(\"userManager\")时，会走到实例化UserManager 具体时配置类AppConfig的代理实现类的方法反射执行的@Bean注解里面的代码逻辑 4 最后是bean生命周期方法了 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2022-05-29 08:36:13 "},"doc/bean/configuration.html":{"url":"doc/bean/configuration.html","title":"@Configuration","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 @Configuration @Configuration注解使用与代理现象 @Configuration到底做了什么操作? 【*】@Configuration的Bean怎么加入到beanDefinitionMap中 register(annotatedClasses); 经过register(annotatedClasses);方法后:xyzConfig加入到了beanDefinitionMap refresh()方法的invokeBeanFactoryPostProcessors(beanFactory);发生了BeanDefinitionMap的改变 重点分析：invokeBeanFactoryPostProcessors(beanFactory); 继续进入PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法 继续进入到ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(registry)方法 @Configuration的beanDefinition添加全注解属性 分析：ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);方法最后实现了代理 在进行enhanceConfigurationClasses(beanFactory);完成了对@Configuration类的Cglib代理 直接new了ConfigurationClassEnhancer（进行Cglib代理改变beanClass属性） Config类的BeanMethod的@Bean覆盖x,y的BeanDefinition processConfigBeanDefinitions(registry);内继续debug看x()方法的@Bean`加载到beanDefinitionMap 在类DefaultListableBeanFactory的registerBeanDefinition方法中可以看到beanDefinitionMap.put(\"x\", beanDefinition) 当BeanDefinition全部到位后，接下来继续refresh方法，会走到单例bean生命周期 @Configuration @Configuration注解使用与代理现象 package com.test.config; import com.test.entity.X; import com.test.entity.Y; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @Author mubi * @Date 2020/7/8 22:38 */ @Configuration public class XyzConfig { @Bean public X x(){ return new X(); } @Bean public Y y(){ x(); return new Y(); } } 测试输出如下(X,Y两个对象都只初始化一次) @Test public void testXyzConfig(){ AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(XyzConfig.class); X x = (X)ac.getBean(\"x\"); Y y = (Y)ac.getBean(\"y\"); Assert.assertTrue(x != null); Assert.assertTrue(y != null); } 输出如下 init X init Y XyzConfig对象由于加上@Configuration后被代理了(否则输出绝对不会是上面的情况) debug 查看XyzConfigBean使用了Cglib代理 @Test public void testXyzConfig(){ AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(XyzConfig.class); XyzConfig config = ac.getBean(XyzConfig.class); X x = (X)ac.getBean(\"x\"); Y y = (Y)ac.getBean(\"y\"); Assert.assertTrue(x != null); Assert.assertTrue(y != null); } @Configuration到底做了什么操作? 常规思路：一步一步debug源码，可能的地方，断点反复看；不过还是需要一定基础和目标 首先要知道：bean一定有个BeanDefinition；其次Spring是有MapperScan,ComponentScan这种扫描注解功能的 所以@Configuration是扫描出来并加载的吗？ 显然Spring提供扫描Bean功能，这需要一个、至少一个@Configuration类，所以@Configuration肯定不是扫描方式的；事实上其是手动register的 带着问题看源码，同时还有问题是：bean x,y 是什么时候生成BeanDefinition并写入到BeanDefinitionMap中的 【*】@Configuration的Bean怎么加入到beanDefinitionMap中 在newAnnotationConfigApplicationContext的时候会执行register(annotatedClasses);方法，紧接着是refresh方法; AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(XyzConfig.class); public AnnotationConfigApplicationContext(Class... annotatedClasses) { this(); register(annotatedClasses); refresh(); } register(annotatedClasses); /** * Register one or more annotated classes to be processed. * Note that {@link #refresh()} must be called in order for the context * to fully process the new classes. * @param annotatedClasses one or more annotated classes, * e.g. {@link Configuration @Configuration} classes * @see #scan(String...) * @see #refresh() */ public void register(Class... annotatedClasses) { Assert.notEmpty(annotatedClasses, \"At least one annotated class must be specified\"); this.reader.register(annotatedClasses); } 会执行doRegisterBean方法注册BeanDefinition； 回答：`@Configuration`的Bean是直接手动注册的，而非scan扫描方式 void doRegisterBean(Class annotatedClass, @Nullable Supplier instanceSupplier, @Nullable String name, @Nullable Class[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) { // annotatedClass 直接 new 成 AnnotatedGenericBeanDefinition // 然后加入到beanDefinitionMap中 AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass); if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) { return; } abd.setInstanceSupplier(instanceSupplier); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd); abd.setScope(scopeMetadata.getScopeName()); String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry)); AnnotationConfigUtils.processCommonDefinitionAnnotations(abd); if (qualifiers != null) { for (Class qualifier : qualifiers) { if (Primary.class == qualifier) { abd.setPrimary(true); } else if (Lazy.class == qualifier) { abd.setLazyInit(true); } else { abd.addQualifier(new AutowireCandidateQualifier(qualifier)); } } } for (BeanDefinitionCustomizer customizer : definitionCustomizers) { customizer.customize(abd); } BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); } BeanDefinition首先会构造出来,并设置属性，包括如下 scope lazyInit dependsOn ... @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { this.beanFactory.registerBeanDefinition(beanName, beanDefinition); } BeanDefinition加入到beanFactory的beanDefinitionMap中 @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { ... // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName); 经过register(annotatedClasses);方法后:xyzConfig加入到了beanDefinitionMap 如下图可以看到： xyzConfig的BeanDefinition已经加入到BeanFactory的beanDefinitionMap中了 Bean x, y 还没有加入到beanDefinitionMap中 xyzConfig的BeanDefinition看起来是XyzConfig类自身，没有什么代理 refresh()方法的invokeBeanFactoryPostProcessors(beanFactory);发生了BeanDefinitionMap的改变 当debug执行完这一行后，发现beanFactory的beanDefinitionMap有变化，如下图 bean x,y 已经加入到beanDefinitionMap中了 同时发现xyzConfig被Spring增强了，这里就可能发生了什么代理行为？ 重点分析：invokeBeanFactoryPostProcessors(beanFactory); /** * Instantiate and invoke all registered BeanFactoryPostProcessor beans, * respecting explicit order if given. * Must be called before singleton instantiation. */ protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } 继续进入PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法 其中beanFactoryPostProcessors是空的 public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List beanFactoryPostProcessors) { // 此方法的这句导致了`beanDefinitionMap`的变化 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 此次是ConfigurationClassPostProcessor,即@Configuration类的后置处理器 /** * Invoke the given BeanDefinitionRegistryPostProcessor beans. */ private static void invokeBeanDefinitionRegistryPostProcessors( Collection postProcessors, BeanDefinitionRegistry registry) { for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeanDefinitionRegistry(registry); } } 继续进入到ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(registry)方法 /** * Derive further bean definitions from the configuration classes in the registry. */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { int registryId = System.identityHashCode(registry); if (this.registriesPostProcessed.contains(registryId)) { throw new IllegalStateException( \"postProcessBeanDefinitionRegistry already called on this post-processor against \" + registry); } if (this.factoriesPostProcessed.contains(registryId)) { throw new IllegalStateException( \"postProcessBeanFactory already called on this post-processor against \" + registry); } this.registriesPostProcessed.add(registryId); processConfigBeanDefinitions(registry); } processConfigBeanDefinitions(registry);处理如下 会判断是否有@Configuration classes（本例有且只有一个xyzConfigbean） 获取Configuration配置的bean，并加入到Set candidates 对candidates中的BeanDefinitionHolder进行校验和bean扫描加载 @Configuration的beanDefinition添加全注解属性 for (String beanName : candidateNames) { BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) { if (logger.isDebugEnabled()) { logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef); } } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } } 在遍历beanDefinitionMap中的已经加入的所有bean中，会逐一遍历判断是否是全注解类（是否加了@Configuration） 第一次判断肯定不是，因为xyzConfig虽然有@Configuration，但是并没有进行任何解析和设置操作 判断不是，而后的checkConfigurationClassCandidate做了操作？ 分析：ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) /** * Check whether the given bean definition is a candidate for a configuration class * (or a nested component class declared within a configuration/component class, * to be auto-registered as well), and mark it accordingly. * @param beanDef the bean definition to check * @param metadataReaderFactory the current factory in use by the caller * @return whether the candidate qualifies as (any kind of) configuration class */ public static boolean checkConfigurationClassCandidate( BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) { // isFullConfigurationCandidate 判断语句：metadata.isAnnotated(Configuration.class.getName()); // 判断是否有@Configuration,这里会判断xyzConfig类是一个全注解类 // 重新设置全注解类的属性，下次就不需要再checkConfigurationClassCandidate了 if (isFullConfigurationCandidate(metadata)) { beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL); } PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);方法最后实现了代理 在ConfigurationClassPostProcessor类中看到了enhanceConfigurationClasses(beanFactory); @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) { throw new IllegalStateException( \"postProcessBeanFactory already called on this post-processor against \" + beanFactory); } this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) { // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); } enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); } 在进行enhanceConfigurationClasses(beanFactory);完成了对@Configuration类的Cglib代理 debug进入方法可以看到会对beanFactory中的所有bean判断是否是全注解 因为之前xyzConfig是已经设置了全注解的，所以这里肯定判断是，并加入到configBeanDefs 只要configBeanDefs不是空，程序继续走，就有了代理；如下图的debug，事实也确实如此 直接new了ConfigurationClassEnhancer（进行Cglib代理改变beanClass属性） 这里看到了xyzConfig全注解bean的beanDefinitiond的beanClass属性变成了代理类 /** * Post-processes a BeanFactory in search of Configuration class BeanDefinitions; * any candidates are then enhanced by a {@link ConfigurationClassEnhancer}. * Candidate status is determined by BeanDefinition attribute metadata. * @see ConfigurationClassEnhancer */ public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) { Map configBeanDefs = new LinkedHashMap<>(); for (String beanName : beanFactory.getBeanDefinitionNames()) { BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) { if (!(beanDef instanceof AbstractBeanDefinition)) { throw new BeanDefinitionStoreException(\"Cannot enhance @Configuration bean definition '\" + beanName + \"' since it is not stored in an AbstractBeanDefinition subclass\"); } else if (logger.isInfoEnabled() && beanFactory.containsSingleton(beanName)) { logger.info(\"Cannot enhance @Configuration bean definition '\" + beanName + \"' since its singleton instance has been created too early. The typical cause \" + \"is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor \" + \"return type: Consider declaring such methods as 'static'.\"); } configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); } } if (configBeanDefs.isEmpty()) { // nothing to enhance -> return immediately return; } ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry entry : configBeanDefs.entrySet()) { AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); try { // Set enhanced subclass of the user-specified bean class Class configClass = beanDef.resolveBeanClass(this.beanClassLoader); if (configClass != null) { Class enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) { if (logger.isTraceEnabled()) { logger.trace(String.format(\"Replacing bean definition '%s' existing class '%s' with \" + \"enhanced class '%s'\", entry.getKey(), configClass.getName(), enhancedClass.getName())); } beanDef.setBeanClass(enhancedClass); } } } catch (Throwable ex) { throw new IllegalStateException(\"Cannot load configuration class: \" + beanDef.getBeanClassName(), ex); } } } Config类的BeanMethod的@Bean覆盖x,y的BeanDefinition processConfigBeanDefinitions(registry);内继续debug看x()方法的@Bean`加载到beanDefinitionMap ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForBeanMethod方法 此方法会判断是否有覆盖的beanDefinition // Has this effectively been overridden before (e.g. via XML)? if (isOverriddenByExistingDefinition(beanMethod, beanName)) { if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) { throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(), beanName, \"Bean name derived from @Bean method '\" + beanMethod.getMetadata().getMethodName() + \"' clashes with bean name for containing configuration class; please make those names unique!\"); } return; } 构造并注册bean x 在类DefaultListableBeanFactory的registerBeanDefinition方法中可以看到beanDefinitionMap.put(\"x\", beanDefinition) 当BeanDefinition全部到位后，接下来继续refresh方法，会走到单例bean生命周期 参考复习：单例bean生命周期 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-11-19 09:14:32 "},"doc/bean/configuration_bean.html":{"url":"doc/bean/configuration_bean.html","title":"@Configuration & @Bean作用同一个类","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 @Component,@Bean同时作用同一个类 测试程序 结论 源码流程 @Component,@Bean同时作用同一个类 测试程序 @Configuration @ComponentScan(\"com.test\") public class UserConfig { @Value(\"${key1}\") String userName; @Bean public UserManager userManager(){ UserManager userManager = new UserManager(userName); return userManager; } } @Component public class UserManager { String userName; public UserManager() { System.out.println(\"constructor UserManager()\"); } public UserManager(String userName) { this.userName = userName; System.out.println(\"constructor UserManager(String userName)\"); } } @Component public class UserPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer { @Override protected void loadProperties(Properties props) throws IOException { super.loadProperties(props); props.put(\"key1\", \"value1\"); } } 测试代码 public static void main(String[] args) { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(UserConfig.class); UserManager userManager = ac.getBean(UserManager.class); System.out.println(userManager); } 结论 默认 @Configuration + @Bean 会覆盖 @Component 源码流程 在执行ConfigurationClassPostProcessor的postProcessBeanFactory方法时，BeanDefinition会注册两次 第一次：ConfigurationClassPostProcessor内部的@ComponentScan扫描bean完成注册 第二次：ConfigurationClassPostProcessor全注解类内部的@Bean方法解析去注册bean,而这会对第一次的注册进行覆盖 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2022-05-28 22:38:35 "},"doc/bean/mapper_scan.html":{"url":"doc/bean/mapper_scan.html","title":"@MapperScan 原理","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 @MapperScan 原理 回顾 ConfigurationClassPostProcessor @MapperScan MapperScannerConfigurer类定义可以看到其实现了BeanDefinitionRegistryPostProcessor @MapperScan 原理 回顾 ConfigurationClassPostProcessor org.springframework.context.support.AbstractApplicationContext#refresh invokeBeanFactoryPostProcessors(beanFactory); org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors // ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry ConfigurationClassPostProcessor具体执行 先判断了@Configuration全注解，然后得到全注解bean,作为candidate 然后会new一个ConfigurationClassParser 首先执行了parser.parse(candidates); 完成Spring自己的bean扫描，并做了其它处理 org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass可以看到扫描，且扫描出来都是都是ScannedGenericBeanDefinition 在parser.parse(candidates);过程中可以看到 // Process any @Import annotations // Process any @ImportResource annotations // Process individual @Bean methods // Process default methods on interfaces // Process superclass, if any 其中@Import种类很多，实现了某个特定接口的需要特殊处理 1. ImportSelector 2. ImportBeanDefinitionRegistrar 3. 其它@Import // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -> // process it as an @Configuration class 对于ImportBeanDefinitionRegistrar是put到了一个如下的map中 private final Map importBeanDefinitionRegistrars = new LinkedHashMap<>(); 是在this.reader.loadBeanDefinitions(configClasses);这句去执行ImportBeanDefinitionRegistrar的 private void loadBeanDefinitionsFromRegistrars(Map registrars) { registrars.forEach((registrar, metadata) -> registrar.registerBeanDefinitions(metadata, this.registry)); } 其中ImportBeanDefinitionRegistrar是个接口，能够将自己定义BeanDefinition注册到Spring容器中 public interface ImportBeanDefinitionRegistrar { /** * Register bean definitions as necessary based on the given annotation metadata of * the importing {@code @Configuration} class. * Note that {@link BeanDefinitionRegistryPostProcessor} types may not be * registered here, due to lifecycle constraints related to {@code @Configuration} * class processing. * @param importingClassMetadata annotation metadata of the importing class * @param registry current bean definition registry */ public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry); } @MapperScan spring-mybatis的 @MapperScan 注解定义如下 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Import(MapperScannerRegistrar.class) @Repeatable(MapperScans.class) public @interface MapperScan { 可以看到import了一个MapperScannerRegistrar，其定义如下(实现了ImportBeanDefinitionRegistrar) public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware { 根据前文介绍，会走到MapperScannerRegistrar的registerBeanDefinitions方法，如下（不过不同版本的MapperScannerRegistrar可能里面的实现是不一样的） 可以看到注册了一个bean:org.mybatis.spring.mapper.MapperScannerConfigurer MapperScannerConfigurer类定义可以看到其实现了BeanDefinitionRegistryPostProcessor public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware { /** * Extension to the standard {@link BeanFactoryPostProcessor} SPI, allowing for * the registration of further bean definitions before regular * BeanFactoryPostProcessor detection kicks in. In particular, * BeanDefinitionRegistryPostProcessor may register further bean definitions * which in turn define BeanFactoryPostProcessor instances. * * @author Juergen Hoeller * @since 3.0.1 * @see org.springframework.context.annotation.ConfigurationClassPostProcessor */ public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor { /** * Modify the application context's internal bean definition registry after its * standard initialization. All regular bean definitions will have been loaded, * but no beans will have been instantiated yet. This allows for adding further * bean definitions before the next post-processing phase kicks in. * @param registry the bean definition registry used by the application context * @throws org.springframework.beans.BeansException in case of errors */ void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; } 我们知道Spring的自己的ConfigurationClassPostProcessor是实现了BeanDefinitionRegistryPostProcessor的,它完成了对Spring bean的扫描，那么容易猜想到MapperScannerConfigurer能实现对mybatis的@MapperScan的bean扫描出来，并加到Spring中 查看org.mybatis.spring.mapper.MapperScannerConfigurer.postProcessBeanDefinitionRegistry，可以看到mybatis自己定义了扫描器去扫描加载BeanDefinition @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { if (this.processPropertyPlaceHolders) { processPropertyPlaceHolders(); } ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass); if (StringUtils.hasText(lazyInitialization)) { scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization)); } scanner.registerFilters(); scanner.scan( StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)); } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-30 09:05:35 "},"doc/bean/bean_post_processor.html":{"url":"doc/bean/bean_post_processor.html","title":"BeanPostProcessor","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 BeanPostProcessor ApplicationContextAwareProcessor 类 InstantiationAwareBeanPostProcessor 接口 SmartInstantiationAwareBeanPostProcessor 接口 DestructionAwareBeanPostProcessor 接口 MergedBeanDefinitionPostProcessor 接口 第一次调用BeanPostProcessor判断是否要进行AOP 回顾循环依赖的lambda表达式提早实现AOP BeanPostProcessor 1.8.1. Customizing Beans by Using a BeanPostProcessor 官网介绍归纳 BeanPostProcessor接口定义了两个回调方法，通过实现这两个方法可以提供自己的实例化以及依赖注入等逻辑。即干预Bean在Spring容器的实例化、配置、初始化逻辑 可以配置多个BeanPostProcessor，如果实现Ordered接口，还可以控制这些BeanPostProcessor执行的顺序 接口定义如下 public interface BeanPostProcessor { /** * Apply this BeanPostProcessor to the given new bean instance before any bean * initialization callbacks (like InitializingBean's {@code afterPropertiesSet} * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original. * The default implementation returns the given {@code bean} as-is. * @param bean the new bean instance * @param beanName the name of the bean * @return the bean instance to use, either the original or a wrapped one; * if {@code null}, no subsequent BeanPostProcessors will be invoked * @throws org.springframework.beans.BeansException in case of errors * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet */ @Nullable default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } /** * Apply this BeanPostProcessor to the given new bean instance after any bean * initialization callbacks (like InitializingBean's {@code afterPropertiesSet} * or a custom init-method). The bean will already be populated with property values. * The returned bean instance may be a wrapper around the original. * In case of a FactoryBean, this callback will be invoked for both the FactoryBean * instance and the objects created by the FactoryBean (as of Spring 2.0). The * post-processor can decide whether to apply to either the FactoryBean or created * objects or both through corresponding {@code bean instanceof FactoryBean} checks. * This callback will also be invoked after a short-circuiting triggered by a * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method, * in contrast to all other BeanPostProcessor callbacks. * The default implementation returns the given {@code bean} as-is. * @param bean the new bean instance * @param beanName the name of the bean * @return the bean instance to use, either the original or a wrapped one; * if {@code null}, no subsequent BeanPostProcessors will be invoked * @throws org.springframework.beans.BeansException in case of errors * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet * @see org.springframework.beans.factory.FactoryBean */ @Nullable default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; } } ApplicationContextAwareProcessor 类 ApplicationContextAwareProcessor是一个Spring内部工具，它实现了接口BeanPostProcessor，用于向实现了如下某种Aware接口的bean设置ApplicationContext中相应的属性: EnvironmentAware EmbeddedValueResolverAware ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware ApplicationContextAware 如果bean实现了以上接口中的某几个，那么这些接口方法调用的先后顺序就是上面接口排列的先后顺序。 InstantiationAwareBeanPostProcessor 接口 public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor { // 在Bean实例化之前调用 @Nullable default Object postProcessBeforeInstantiation(Class beanClass, String beanName) throws BeansException { return null; } // 在Bean实例化之后调用 default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { return true; } // 采用注解时，Spring通过这个方法完成了属性注入 @Nullable default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { return null; } @Deprecated @Nullable default PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException { return pvs; } } SmartInstantiationAwareBeanPostProcessor 接口 public interface SmartInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessor { // 预测Bean的类型，主要是在Bean还没有创建前我们可以需要获取Bean的类型 @Nullable default Class predictBeanType(Class beanClass, String beanName) throws BeansException { return null; } // 完成构造函数的推断 @Nullable default Constructor[] determineCandidateConstructors(Class beanClass, String beanName) throws BeansException { return null; } // 主要为了解决循环依赖，Spring内部使用这个方法：能让早期曝光的\"半成品\"对象成为一个“成品”对象 default Object getEarlyBeanReference(Object bean, String beanName) throws BeansException { return bean; } } DestructionAwareBeanPostProcessor 接口 public interface DestructionAwareBeanPostProcessor extends BeanPostProcessor { // 在Bean被销毁前调用 void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException; // 判断是否需要被销毁，默认都需要 default boolean requiresDestruction(Object bean) { return true; } } MergedBeanDefinitionPostProcessor 接口 public interface MergedBeanDefinitionPostProcessor extends BeanPostProcessor { // Spring内部主要使用这个方法找出了所有需要注入的字段，同时做了缓存 void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class beanType, String beanName); // 主要用于在BeanDefinition被修改后，清除容器中的缓存 default void resetBeanDefinition(String beanName) { } } 第一次调用BeanPostProcessor判断是否要进行AOP org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation /** * Apply before-instantiation post-processors, resolving whether there is a * before-instantiation shortcut for the specified bean. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @return the shortcut-determined bean instance, or {@code null} if none */ @Nullable protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) { Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) { // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { Class targetType = determineTargetType(beanName, mbd); if (targetType != null) { bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) { bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); } } } mbd.beforeInstantiationResolved = (bean != null); } return bean; } /** * Apply InstantiationAwareBeanPostProcessors to the specified bean definition * (by class and name), invoking their {@code postProcessBeforeInstantiation} methods. * Any returned object will be used as the bean instead of actually instantiating * the target bean. A {@code null} return value from the post-processor will * result in the target bean being instantiated. * @param beanClass the class of the bean to be instantiated * @param beanName the name of the bean * @return the bean object to use instead of a default instance of the target bean, or {@code null} * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation */ @Nullable protected Object applyBeanPostProcessorsBeforeInstantiation(Class beanClass, String beanName) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) { return result; } } } return null; } org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessBeforeInstantiation 判断是否要代理（分阶段），此阶段不代理的类(或者已经代理过的类)存储起来到advisedBeans中，比如Config类 @Override public Object postProcessBeforeInstantiation(Class beanClass, String beanName) { Object cacheKey = getCacheKey(beanClass, beanName); if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) { if (this.advisedBeans.containsKey(cacheKey)) { return null; } // 判断是否需要代理 if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; } } // Create proxy here if we have a custom TargetSource. // Suppresses unnecessary default instantiation of the target bean: // The TargetSource will handle target instances in a custom fashion. TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) { if (StringUtils.hasLength(beanName)) { this.targetSourcedBeans.add(beanName); } Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } return null; } 两个条件：isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName) org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#isInfrastructureClass aop自身的一些类（切面，切点等）是不需要被代理的，因为这些类就是代理逻辑（再代理就无限代理循环了） protected boolean isInfrastructureClass(Class beanClass) { boolean retVal = Advice.class.isAssignableFrom(beanClass) || Pointcut.class.isAssignableFrom(beanClass) || Advisor.class.isAssignableFrom(beanClass) || AopInfrastructureBean.class.isAssignableFrom(beanClass); if (retVal && logger.isTraceEnabled()) { logger.trace(\"Did not attempt to auto-proxy infrastructure class [\" + beanClass.getName() + \"]\"); } return retVal; } 回顾循环依赖的lambda表达式提早实现AOP addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); /** * Obtain a reference for early access to the specified bean, * typically for the purpose of resolving a circular reference. * @param beanName the name of the bean (for error handling purposes) * @param mbd the merged bean definition for the bean * @param bean the raw bean instance * @return the object to expose as bean reference */ protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) { Object exposedObject = bean; if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { for (BeanPostProcessor bp : getBeanPostProcessors()) { // bean的后置处理器中，只取`SmartInstantiationAwareBeanPostProcessor` if (bp instanceof SmartInstantiationAwareBeanPostProcessor) { SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp; exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName); } } } return exposedObject; } 接着会执行org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#getEarlyBeanReference @Override public Object getEarlyBeanReference(Object bean, String beanName) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) { this.earlyProxyReferences.add(cacheKey); } return wrapIfNecessary(bean, beanName, cacheKey); } org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy /** * Create an AOP proxy for the given bean. * @param beanClass the class of the bean * @param beanName the name of the bean * @param specificInterceptors the set of interceptors that is * specific to this bean (may be empty, but not null) * @param targetSource the TargetSource for the proxy, * already pre-configured to access the bean * @return the AOP proxy for the bean * @see #buildAdvisors */ protected Object createProxy(Class beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) { if (this.beanFactory instanceof ConfigurableListableBeanFactory) { AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); } ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (!proxyFactory.isProxyTargetClass()) { if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } return proxyFactory.getProxy(getProxyClassLoader()); } 最后完成AOP代理 关于使用JDK动态还是CGLIB动态代理 org.springframework.aop.framework.DefaultAopProxyFactory public class DefaultAopProxyFactory implements AopProxyFactory, Serializable { @Override public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) { Class targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\"TargetSource cannot determine target class: \" + \"Either an interface or a target is required for proxy creation.\"); } if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } } /** * Determine whether the supplied {@link AdvisedSupport} has only the * {@link org.springframework.aop.SpringProxy} interface specified * (or no proxy interfaces specified at all). */ private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) { Class[] ifcs = config.getProxiedInterfaces(); return (ifcs.length == 0 || (ifcs.length == 1 && SpringProxy.class.isAssignableFrom(ifcs[0]))); } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-10 18:47:05 "},"doc/bean/bean_smart.html":{"url":"doc/bean/bean_smart.html","title":"SmartInstantiationAwareBeanPostProcessor","keywords":"","body":"SmartInstantiationAwareBeanPostProcessor public interface SmartInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessor { /** * Predict the type of the bean to be eventually returned from this * processor's {@link #postProcessBeforeInstantiation} callback. * The default implementation returns {@code null}. * @param beanClass the raw class of the bean * @param beanName the name of the bean * @return the type of the bean, or {@code null} if not predictable * @throws org.springframework.beans.BeansException in case of errors */ @Nullable default Class predictBeanType(Class beanClass, String beanName) throws BeansException { return null; } /** * Determine the candidate constructors to use for the given bean. * The default implementation returns {@code null}. * @param beanClass the raw class of the bean (never {@code null}) * @param beanName the name of the bean * @return the candidate constructors, or {@code null} if none specified * @throws org.springframework.beans.BeansException in case of errors */ @Nullable default Constructor[] determineCandidateConstructors(Class beanClass, String beanName) throws BeansException { return null; } /** * Obtain a reference for early access to the specified bean, * typically for the purpose of resolving a circular reference. * This callback gives post-processors a chance to expose a wrapper * early - that is, before the target bean instance is fully initialized. * The exposed object should be equivalent to the what * {@link #postProcessBeforeInitialization} / {@link #postProcessAfterInitialization} * would expose otherwise. Note that the object returned by this method will * be used as bean reference unless the post-processor returns a different * wrapper from said post-process callbacks. In other words: Those post-process * callbacks may either eventually expose the same reference or alternatively * return the raw bean instance from those subsequent callbacks (if the wrapper * for the affected bean has been built for a call to this method already, * it will be exposes as final bean reference by default). * The default implementation returns the given {@code bean} as-is. * @param bean the raw bean instance * @param beanName the name of the bean * @return the object to expose as bean reference * (typically with the passed-in bean instance as default) * @throws org.springframework.beans.BeansException in case of errors */ default Object getEarlyBeanReference(Object bean, String beanName) throws BeansException { return bean; } } 1 创建bean的过程中，实例化后会执行添加三级缓存的操作 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException { BeanWrapper instanceWrapper = null; //省略其他代码…… //从beanWrapper中获取我们的早期对象（实例化后的对象） final Object bean = instanceWrapper.getWrappedInstance(); //省略其他代码…… //缓存单例到三级缓存中，以防循环依赖 boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName)); //上述条件满足，允许中期暴露对象 if (earlySingletonExposure) { //把我们的早期对象包装成一个singletonFactory对象 该对象提供了一个getObject方法,该方法内部调用getEarlyBeanReference方法 addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); } //省略其他代码…… } 2 三级缓存是个lambda表达，一个ObjectFactory(对象工厂,用来生成早期对象，放到二级缓存中) addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); addSingletonFactory方法如下： protected void addSingletonFactory(String beanName, ObjectFactory singletonFactory) { Assert.notNull(singletonFactory, \"Singleton factory must not be null\"); //同步加锁 synchronized (this.singletonObjects) { //单例缓存池中没有包含当前的bean if (!this.singletonObjects.containsKey(beanName)) { //加入到三级缓存中，，，，，暴露早期对象用于解决循环依赖 this.singletonFactories.put(beanName, singletonFactory); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); } } ... getEarlyBeanReference方法如下: protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) { Object exposedObject = bean; //判读我们容器中是否有InstantiationAwareBeanPostProcessors类型的后置处理器 if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { //获取我们所有的后置处理器 for (BeanPostProcessor bp : getBeanPostProcessors()) { //判断我们的后置处理器是不是实现了SmartInstantiationAwareBeanPostProcessor接口 if (bp instanceof SmartInstantiationAwareBeanPostProcessor) { //进行强制转换 SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp; //挨个调用SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName); } } } return exposedObject; 3 早期对象创建则是要对实例对象执行所有SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法 AbstractAutoProxyCreator是SmartInstantiationAwareBeanPostProcessor的实现类之一，其重写了getEarlyBeanReference方法 @Override public Object getEarlyBeanReference(Object bean, String beanName) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) { this.earlyProxyReferences.add(cacheKey); } return wrapIfNecessary(bean, beanName, cacheKey); } 4 getEarlyBeanReference 实现中的 getEarlyBeanReference 方法完成 protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { //已经被处理过（解析切面时targetSourcedBeans出现过） 就是自己实现创建动态代理逻辑 if (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) { return bean; } //不需要增强的 if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } //是不是基础的bean 是不是需要跳过的 重复判断 （ 因为循环依赖是可以改变bean的，如果把bean改成了advisor呢） if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } // 根据当前bean找到匹配的advisor Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); // 当前bean匹配到了advisor if (specificInterceptors != DO_NOT_PROXY) { // 标记为已处理 this.advisedBeans.put(cacheKey, Boolean.TRUE); //创建我们的真正的代理对象 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); //加入到缓存 this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } 其最后返回的是增强后的bean对象 5 代理对象由aop创建(AbstractAutoProxyCreator的createProxy方法) /** * Create an AOP proxy for the given bean. * @param beanClass the class of the bean * @param beanName the name of the bean * @param specificInterceptors the set of interceptors that is * specific to this bean (may be empty, but not null) * @param targetSource the TargetSource for the proxy, * already pre-configured to access the bean * @return the AOP proxy for the bean * @see #buildAdvisors */ protected Object createProxy(Class beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) { if (this.beanFactory instanceof ConfigurableListableBeanFactory) { AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); } ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (!proxyFactory.isProxyTargetClass()) { if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } return proxyFactory.getProxy(getProxyClassLoader()); } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2022-05-29 09:37:38 "},"doc/bean/bean_constructor.html":{"url":"doc/bean/bean_constructor.html","title":"推断构造方法","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 推断构造方法 如何去确定到底用哪个构造方法? xml构造函数的配置 推断构造方法 bean实例化是根据构造函数来反射生成的，如何判断构造函数的生成则是在如下代码中 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) { // 解析class，确保class不为空，并且访问权限为public // Make sure bean class is actually resolved at this point. Class beanClass = resolveBeanClass(mbd, beanName); if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); } // 配置的一种特殊的callback回调方法，通过这个callback创建bean Supplier instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) { return obtainFromSupplier(instanceSupplier, beanName); } // 通过工厂方法创建 if (mbd.getFactoryMethodName() != null) { return instantiateUsingFactoryMethod(beanName, mbd, args); } // 一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器 // 在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，避免再次创建相同bean时再次解析 // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { if (autowireNecessary) { // 有已经解析过class的构造器，使用已经解析好的构造器注入 return autowireConstructor(beanName, mbd, null, null); } else { // 默认的构造器 return instantiateBean(beanName, mbd); } } // 从BeanPostProcessor推断构造方法 // 根据参数解析、确定构造函数，然后实例化 // Candidate constructors for autowiring? Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { // return autowireConstructor(beanName, mbd, ctors, args); } // Preferred constructors for default construction? ctors = mbd.getPreferredConstructors(); if (ctors != null) { return autowireConstructor(beanName, mbd, ctors, null); } // No special handling: simply use no-arg constructor. return instantiateBean(beanName, mbd); } 如何去确定到底用哪个构造方法? 如果开发者指定了想要使用的构造方法，那么就用这个构造方法 如果开发者没有指定想要使用的构造方法，则看开发者有没有让Spring自动去选择构造方法 如果开发者也没有让Spring自动去选择构造方法，则Spring利用无参构造方法，如果没有无参构造方法，则报错 如何指定构造方法： xml中的标签，这个标签表示构造方法参数，所以可以根据这个确定想要使用的构造方法的参数个数，从而确定想要使用的构造方法 通过@Autowired注解，@Autowired注解可以写在构造方法上，所以哪个构造方法上写了@Autowired注解，表示开发者想使用哪个构造方法，当然，它和第一个方式的不同点是，通过xml的方式，我们直接指定了构造方法的参数值，而通过@Autowired注解的方式，需要Spring通过byType+byName的方式去找到符合条件的bean作为构造方法的参数值 xml构造函数的配置 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-10-24 12:01:56 "},"doc/bean/ioc_bean_auto.html":{"url":"doc/bean/ioc_bean_auto.html","title":"自动装配 & @Autowired","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 自动装配 & @Autowired 手动装配例子 自动装配优点 自动装配缺点 自动装配方式(默认：非自动装配) 非自动装配例子 byName自动注入,但是set方法name不匹配,也无法注入 自动装配常见的 No qualifying bean of type错误 自定义 BeanNameGenerator 自动装配在populateBean阶段完成注入 @Autowired是通过byType来完成注入的？ AutowiredAnnotationBeanPostProcessor解析@AutoWired和@Value的属性或方法，把其封装成InjectionMetadata类 populateBean阶段赋值标注@AutoWired和@Value的属性或方法 AutowiredFieldElement的inject(利用反射filed.set) 非自动配置下通过构造函数进行注入 自动装配 & @Autowired Autowiring Collaborators IOC注入需要提供依赖关系：一是类中定义，二是spring的配置中定义好描述关系，而自动装配把第二种方式取消了，这样只需要在类中提供依赖关系，使用自动转配就能交给容易完成依赖关系 推荐博客文章：子路：spring自动注入 手动装配例子 public class A { B b; public void setB(B b) { this.b = b; } } public class B { } // 然后xml手动指定依赖关系，然后set方法就能设置好依赖bean（即setter注入方式采用手动方式完成） 自动装配优点 Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.) Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable. 自动装配可以减少属性依赖设置和构造参数依赖设置 自动装配也可以在解析对象时更新配置 自动装配缺点 Consider the limitations and disadvantages of autowiring: Explicit dependencies in property and constructor-arg settings always override autowiring. You cannot autowire simple properties such as primitives, Strings, and Classes (and arrays of such simple properties). This limitation is by-design. Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results. The relationships between your Spring-managed objects are no longer documented explicitly. Wiring information may not be available to tools that may generate documentation from a Spring container. Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Map instances, this is not necessarily a problem. However, for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown. 在property和constructor-arg设置中的依赖总是重载自动装配，我们无法对原始类型（如int，long，boolean等就是首字母小写的那些类型），还有String，Classes做自动装配。这是受限于设计。 自动装配跟直接装配（explicit wiring）相比较，在准确性方便还是差那么点，虽然没有明确地说明，但是Spring还是尽量避免这种模棱两可的情况，导致出现没预料到的结果。 Spring容器生成文档的工具可能会不能使用装配的信息。 容器中多个bean的定义可能要对setter和构造器参数做类型匹配才能做依赖注入，虽然对于array，collection和map来说不是啥问题，但是对于只有单一值的依赖来讲，这就有点讲不清楚了，所以如果没有唯一的bean定义，那只能抛出异常。 自动装配方式(默认：非自动装配) no：默认方式（即默认是手动装配方式，需要通过ref设定bean的依赖关系，不是自动装配的） byName：根据bean的名字进行装配，当一个bean的名称和其它bean的属性一致，则自动装配 byType：根据bean的类型进行装配，当一个bean的属性类型与其它bean的属性的数据类型一致，则自动装配 constructor：根据构造器进行装配，与 byType 类似，如果bean的构造器有与其它bean类型相同的属性，则进行自动装配 源码： AUTOWIRE_NO = 0; AUTOWIRE_BY_NAME = 1; AUTOWIRE_BY_TYPE = 2; AUTOWIRE_CONSTRUCTOR = 3; /** * Constant that indicates determining an appropriate autowire strategy * through introspection of the bean class. * @see #createBean * @see #autowire * @deprecated as of Spring 3.0: If you are using mixed autowiring strategies, * prefer annotation-based autowiring for clearer demarcation of autowiring needs. */ @Deprecated int AUTOWIRE_AUTODETECT = 4; 非自动装配例子 public class Ca { /** * Autowired 是手动注入 */ @Autowired Cb cb; /** * 代码能运行起来，A能注入B * 但是在xml配置文件中并没有去手动维护、描述他们之间的依赖关系， * 而是在xml的根标签上面写了一行default-autowire=\"byType\" * 且set方法名子也无所谓，只要里面的type是个bean: cb */ public void setXxx(Cb cb) { System.out.println(\"这个set方法如果配置了自动装配且是byType方式是可以的,byName不行:\" + cb); } public void setCc(Cc cc) { System.out.println(\"cc byName, byType都可以:\" + cc); } public void cbOut(){ System.out.println(\"Cb:\" + cb); } } 如上，非自动装配的情况下，setXxx(Cb cb)方法不会被执行，且setCc(Cc cc)方法也不会执行 byName自动注入,但是set方法name不匹配,也无法注入 public class Ca { /** * Autowired 是手动注入 */ @Autowired Cb cb; /** * 代码能运行起来，A能注入B * 但是在xml配置文件中并没有去手动维护、描述他们之间的依赖关系， * 而是在xml的根标签上面写了一行default-autowire=\"byType\" * 且set方法名子也无所谓，只要里面的type是个bean: cb */ public void setXxx(Cb cb) { System.out.println(\"这个set方法如果配置了自动装配且是byType方式是可以的,byName不行:\" + cb); } public void setCc(Cc cc) { System.out.println(\"cc byName, byType都可以:\" + cc); } public void cbOut(){ System.out.println(\"Cb:\" + cb); } } 如上是byName的自动装配方式，但是setXxx(Cb cb)方法不是setCb(Cb cb)方法，所以该方法不会被执行到 自动装配常见的No qualifying bean of type错误 自定义 BeanNameGenerator eg如下，自定义beanName @ComponentScan(basePackages = \"com.mb.service\", nameGenerator = MyBeanNameGenerator.class) 补充bean名字生成的流程： bean将自己的全路径类名作为自己的bean名字，如果没有类名，那就看是否有父bean，如果有，假设父bean名字为hehe，那么就用hehe$child作为此子bean的名字，如果没有父bean，那就看bean的工厂bean的名字，如果有，假设工厂bean名字为haha，那么bean的名字就是haha$created，如果没有工厂，那就报错“既没有自己的类名、也没有父bean类名、也没有工厂bean类名”。不管最终用的是哪一个的名字，对这个名字进行唯一性检查，如果名字重复了（已经有这个名字存在了），那就在名字后面+#+数字，这样，每个bean的名字就是唯一的了。 自动装配在populateBean阶段完成注入 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean 如下代码 在两种自动注入方式下会去解析依赖的属性 PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // Add property values based on autowire by type if applicable. if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } 找到了属性接着执行org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyPropertyValues,里面有循环依赖的解决,最后设置属性即可 @Autowired是通过byType来完成注入的？ 错误，解释如下 byType仅仅是一种自动注入模型而已(no、byType、byName、constructor) @Autowired是一个注解，这个注解会被spring的后置处理器解析，和处理byType不是同一回事。 理论依据 在不配置BeanFactoryPostProcessor和修改beanDefinition的情况下注解的类是不支持自动装配的；且即使是自动装配，有@Autowired注解，属性也不一定注入进去 结论1：在一个注解类里面提供了一个构造方法之所以能达到和自动注入的效果一样并不是因为这种方式就是自动装配，而是因为spring源码当中做了判断；使这种情况下调用的代码和自动装配调用的逻辑一样 结论2：@Autowried是个手动装配,当然也是可以设置成自动装配的 AutowiredAnnotationBeanPostProcessor解析@AutoWired和@Value的属性或方法，把其封装成InjectionMetadata类 在org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean方法中的populateBean方法之前会应用所有的bpp去修改bean definition public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class beanType, String beanName) { InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } private InjectionMetadata findAutowiringMetadata(String beanName, Class clazz, @Nullable PropertyValues pvs) { // 返回类名作为缓存键，以便与自定义调用方向后兼容。 String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()); // 首先对并发映射进行快速检查，只需最少的锁定。 InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) { synchronized (this.injectionMetadataCache) { metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) { if (metadata != null) { metadata.clear(pvs); } metadata = buildAutowiringMetadata(clazz); this.injectionMetadataCache.put(cacheKey, metadata); } } } return metadata; } private InjectionMetadata buildAutowiringMetadata(final Class clazz) { List elements = new ArrayList<>(); Class targetClass = clazz; do { final List currElements = new ArrayList<>(); //解析属性 ReflectionUtils.doWithLocalFields(targetClass, field -> { //解析当前对象属性，判断其是否有@Autowired和@value注解，如果有返回其注解对象 AnnotationAttributes ann = findAutowiredAnnotation(field); if (ann != null) { //如果属性是静态属性，就不处理 if (Modifier.isStatic(field.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation is not supported on static fields: \" + field); } return; } boolean required = determineRequiredStatus(ann); //把当前属性封装成AutowiredFieldElement对象储存到injectionMetadataCache中 currElements.add(new AutowiredFieldElement(field, required)); } }); //解析方法 ReflectionUtils.doWithLocalMethods(targetClass, method -> { Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) { return; } //解析当前对象属性，判断其是否有@Autowired和@value注解，如果有返回其注解对象 AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) { //如果方法是静态方法，就不处理 if (Modifier.isStatic(method.getModifiers())) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation is not supported on static methods: \" + method); } return; } //如果方法是无参的，就不处理 if (method.getParameterCount() == 0) { if (logger.isInfoEnabled()) { logger.info(\"Autowired annotation should only be used on methods with parameters: \" + method); } } boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); //把当前方法封装成AutowiredMethodElement对象储存到injectionMetadataCache中 currElements.add(new AutowiredMethodElement(method, required, pd)); } }); elements.addAll(0, currElements); //开始解析其父类 targetClass = targetClass.getSuperclass(); } while (targetClass != null && targetClass != Object.class); return new InjectionMetadata(clazz, elements); } populateBean阶段赋值标注@AutoWired和@Value的属性或方法 populateBean阶段会应用所有的InstantiationAwareBeanPostProcessor,而AutowiredAnnotationBeanPostProcessor继承了InstantiationAwareBeanPostProcessorAdapter，见org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean方法 public void inject(Object target, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable { Collection checkedElements = this.checkedElements; Collection elementsToIterate = (checkedElements != null ? checkedElements : this.injectedElements); if (!elementsToIterate.isEmpty()) { // 遍历 InjectedElement 然后inject for (InjectedElement element : elementsToIterate) { if (logger.isTraceEnabled()) { logger.trace(\"Processing injected element of bean '\" + beanName + \"': \" + element); } element.inject(target, beanName, pvs); } } } AutowiredFieldElement的inject(利用反射filed.set) private class AutowiredFieldElement extends InjectionMetadata.InjectedElement { private final boolean required; private volatile boolean cached = false; @Nullable private volatile Object cachedFieldValue; public AutowiredFieldElement(Field field, boolean required) { super(field, null); this.required = required; } @Override protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable{ // 显然此处父类的member就指的是filed Field field = (Field) this.member; Object value; // 走缓存，关于cachedFieldValue的值 if (this.cached) { value = resolvedCachedArgument(beanName, this.cachedFieldValue); } else { // 每个Field都包装成一个DependencyDescriptor // 如果是Method包装成DependencyDescriptor,毕竟一个方法可以有多个入参 // 此处包装成它后，显然和元数据都无关了，只和Field有关了 完全隔离 DependencyDescriptor desc = new DependencyDescriptor(field, this.required); desc.setContainingClass(bean.getClass()); Set autowiredBeanNames = new LinkedHashSet<>(1); Assert.state(beanFactory != null, \"No BeanFactory available\"); // 转换器使用的bean工厂的转换器~~~ TypeConverter typeConverter = beanFactory.getTypeConverter(); try { // 获取依赖的value值的工作 最终还是委托给beanFactory.resolveDependency()去完成的~~~~ //到容器中查询要装配的值，这是自动装配的核心方法。后面出一片文章单独讲解 value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); } catch (BeansException ex) { throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex); } // 下面代码是把缓存值缓存起来 让同一个Field注入多次能提高效率 synchronized (this) { if (!this.cached) { // 可以看到value！=null并且required=true才会进行缓存的处理 if (value != null || this.required) { this.cachedFieldValue = desc; // 简单的说就是注册到bean工厂去，比如此处b是依赖a的 所以就注册这个依赖关系进去了 // 参考this.beanFactory.registerDependentBean(autowiredBeanName, beanName); registerDependentBeans(beanName, autowiredBeanNames); // autowiredBeanNames里可能会有别名的名称~~~所以size可能大于1 if (autowiredBeanNames.size() == 1) { // beanFactory.isTypeMatch挺重要的~~~~因为@Autowired是按照类型注入的 String autowiredBeanName = autowiredBeanNames.iterator().next(); //如果容器中包含这个bean的名字，且类型一样 if (beanFactory.containsBean(autowiredBeanName) &&beanFactory.isTypeMatch(autowiredBeanName, field.getType())) { this.cachedFieldValue = new ShortcutDependencyDescriptor( desc, autowiredBeanName, field.getType()); } } } else { this.cachedFieldValue = null; } this.cached = true; } } } // 不为null，就完成最终的set值 利用反射给filed属性赋值~~~~ if (value != null) { ReflectionUtils.makeAccessible(field); field.set(bean, value); } } } 非自动配置下通过构造函数进行注入 public class IndexService { /** * 这里能注入进来,why? * @param beanService */ public IndexService(BeanService beanService) { System.out.println(\"beanService:\" + beanService); } } 关键代码如下：能找到一个构造函数，或者 自动装配模型是AUTOWIRE_CONSTRUCTOR就可以执行autowireConstructor完成了 Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { return autowireConstructor(beanName, mbd, ctors, args); } 结论：在一个注解类里面提供了一个构造方法之所以能达到和自动注入的效果一样并不是因为这种方式就是自动装配，而是因为spring源码当中做了特殊判断，使这种情况下调用的代码和自动装配调用的逻辑一下。 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-10-23 18:26:47 "},"doc/bean/aop.html":{"url":"doc/bean/aop.html","title":"Spring AOP","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Spring AOP AOP的各种概念 为什么需要aop？ aop应用场合？横切性问题？ aop代码例子 Spring aop Spring aop 术语 Spring aop 通知类型 断点调试技巧 目标对象 =》代理对象 默认jdk动态代理(可以配置使用cglib代理) JDK动态代理为什么必须基于接口？ Spring AOP AOP的各种概念 spring aop reference aop（aspect-oriented programming）面向切面编程 aop是oop的补充和完善，是相互配合关系 aop把软件系统分为两个部分：核心关注点和横切关注点 为什么需要aop？ 公共行为：权限安全，日志记录，事务等功能；这些公共行为与业务逻辑耦合的 aop可以纵向处理 可以将公共行为与业务逻辑分离，解耦合 aop应用场合？横切性问题？ AOP用来封装横切关注点，具体可以在下面的场景中使用 Authentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 日志 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 aop代码例子 aop demo Spring aop Spring aop 术语 Aspect 通常一个类@Aspect Join point(连接点) A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution. 通常就是一个执行的方法 Advice(增强器) Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point. 在特定的Join point增强 1. Before：前置通知，在一个方法执行前被调用 2. After：在方法执行之后调用的通知，无论方法执行是否成功 3. AfterReturn：仅当方法成功完成后执行的通知 4. AfterThrowing：在方法抛出异常退出时执行的通知 5. Around：在方法执行之前和之后调用的通知 Pointcut(切点) A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default. 简单认为是：某些特定的join point的集合 Introduction Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.) Target object（目标对象，被代理的对象，原对象） An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object. 增强对象(新对象，代理对象)也叫this，而被增强的那个原始对象就是Target object Jdk动态代理：this 和 target是实现接口关系，this和target不相同 cglib代理：this 是 target的子类，this和target相同 AOP proxy An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy. Weaving linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime. Spring aop 通知类型 前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。 后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。 最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。 环绕通知是最常用的通知类型。和AspectJ一样，Spring提供所有类型的通知，我们推荐你使用尽可能简单的通知类型来实现需要的功能。例如，如果你只是需要一个方法的返回值来更新缓存，最好使用后置通知而不是环绕通知，尽管环绕通知也能完成同样的事情。用最合适的通知类型可以使得编程模型变得简单，并且能够避免很多潜在的错误。比如，你不需要在JoinPoint上调用用于环绕通知的proceed()方法，就不会有调用的问题。 在Spring 2.0中，所有的通知参数都是静态类型，因此你可以使用合适的类型（例如一个方法执行后的返回值类型）作为通知的参数而不是使用Object数组。 通过切入点匹配连接点的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得通知可以独立对应到面向对象的层次结构中。例如，一个提供声明式事务管理 的环绕通知可以被应用到一组横跨多个对象的方法上（例如服务层的所有业务操作）。 断点调试技巧 断点加条件 Evaluate，断点评估运行 目标对象 =》代理对象 debug 可以定位到initializeBean方法后，返回了代理对象 // Initialize the bean instance. Object exposedObject = bean; try { // 2. 填充bean的属性:即这里要完成bean依赖处理 populateBean(beanName, mbd, instanceWrapper); // 3. bean的initialize,beanPostProcessor等 // 执行完如下一句，exposedObject 是JdkDynamicAopProxy对象 exposedObject = initializeBean(beanName, exposedObject, mbd); } catch (Throwable ex) { if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } 继续debug在applyBeanPostProcessorsAfterInitialization方法返回了代理对象 在某个PostProcessor作用后肯定会变成代理对象 /** * Create a proxy with the configured interceptors if the bean is * identified as one to proxy by the subclass. * @see #getAdvicesAndAdvisorsForBean */ @Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean; } 默认jdk动态代理(可以配置使用cglib代理) Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); 附：@EnableAspectJAutoProxy(proxyTargetClass=true) 使用CGLib代理, 创建AopProxy public class DefaultAopProxyFactory implements AopProxyFactory, Serializable { @Override public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) { Class targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\"TargetSource cannot determine target class: \" + \"Either an interface or a target is required for proxy creation.\"); } // 目标类是一个接口则会使用`JdkDynamicAopProxy`创建代理对象 if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } } } 如果目标对象有实现接口，则使用 JDK 代理，反之使用 CGLIB (JDK 代理是基于接口的) 如果目标类没有实现接口，且 class 为 final 修饰的，则不能进行 Spring AOP JDK动态代理为什么必须基于接口？ 参考：jdk动态代理和cglib动态代理的区别？ Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2022-05-28 22:37:55 "},"doc/bean/aspectj.html":{"url":"doc/bean/aspectj.html","title":"CGLIB & AOP代理","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Aop 代理 CGLIB代理初步认识 附：代理技术 Aop 代理 CGLIB代理初步认识 在使用@Configuration注解时发生了CGLIB代理，但是Config类是可以不用@Configuration的,而使用@Configuration注解能完成代理，这样在config类中@Bean只实例化一次 参见：@Configuration 回顾下：在refresh方法中执行invokeBeanFactoryPostProcessors(beanFactory);是会执行invokeBeanFactoryPostProcessors的（一个是子类的扫描后置处理，一个是父类的后置处理） 会执行到org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法,有重要的一句 enhanceConfigurationClasses(beanFactory); 而org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses对全注解类完成了CGLIB代理 public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) { Map configBeanDefs = new LinkedHashMap<>(); for (String beanName : beanFactory.getBeanDefinitionNames()) { BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) { if (!(beanDef instanceof AbstractBeanDefinition)) { throw new BeanDefinitionStoreException(\"Cannot enhance @Configuration bean definition '\" + beanName + \"' since it is not stored in an AbstractBeanDefinition subclass\"); } else if (logger.isInfoEnabled() && beanFactory.containsSingleton(beanName)) { logger.info(\"Cannot enhance @Configuration bean definition '\" + beanName + \"' since its singleton instance has been created too early. The typical cause \" + \"is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor \" + \"return type: Consider declaring such methods as 'static'.\"); } configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); } } if (configBeanDefs.isEmpty()) { // nothing to enhance -> return immediately return; } ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry entry : configBeanDefs.entrySet()) { AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); try { // Set enhanced subclass of the user-specified bean class Class configClass = beanDef.resolveBeanClass(this.beanClassLoader); if (configClass != null) { Class enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) { if (logger.isTraceEnabled()) { logger.trace(String.format(\"Replacing bean definition '%s' existing class '%s' with \" + \"enhanced class '%s'\", entry.getKey(), configClass.getName(), enhancedClass.getName())); } beanDef.setBeanClass(enhancedClass); } } } catch (Throwable ex) { throw new IllegalStateException(\"Cannot load configuration class: \" + beanDef.getBeanClassName(), ex); } } } 附：代理技术 Spring AOP 属于运行时增强，而 AspectJ 是编译时增强 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation) 附：动态字节码生成代理 编译 ClassLoader加载 实例 .java ------> .class(字节码) -------------------> Class Obj ------------> Class Instance 动态代理主要的几种技术 Java Proxy（接口&反射机制，新增一个完整的class字节码） CGLib（父类继承，新增一个完整的class字节码） AspectJ（修改现有字节码） JavaAgent（修改现有字节码） 类别 机制 原理 优点 缺点 技术 静态AOP 静态织入 在编译期,切面直接以字节码的形式编译到目标字节码文件中 对系统无性能影响 灵活性不够 AspectJ 动态AOP 动态代理 在运行期,目标类加载后，为接口动态生成代理类，将切面植入到代理类中 相对于静态AOP更加灵活 切入的关注点需要实现接口。对系统有一点性能影响 JDK dynamic proxy 动态字节码生成 在运行期 目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中 没有接口也可以织入 扩展类的实例方法为final时，则无法进行织入 cglib 自定义类加载器 在运行期 目标加载前，将切面逻辑加到目标字节码里 可以对绝大部分类进行织入 代码中如果使用了其他类加载器，则这些类将不会被织入 - 字节码转换 在运行期 所有类加载器加载字节码前，前进行拦截 可以对所有类进行织入 - - Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-31 22:55:05 "},"doc/bean/transaction.html":{"url":"doc/bean/transaction.html","title":"Spring 事务","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Spring事务 数据库事务 事务的ACID 事务的一些问题 4种隔离级别 Spring Transaction Management 回顾Jdbc事务配置和使用 Spring事务抽象 PlatformTransactionManager(事务管理器接口) DataSourceTransactionManager 实现 PlatformTransactionManager TransactionDefinition(事务定义信息接口) TransactionStatus(事务运行状态接口) @EnableTransactionManagement AutoProxyRegistrar 注册一个InfrastructureAdvisorAutoProxyCreator组件 ProxyTransactionManagementConfiguration(注册事务增强器) TransactionInterceptor Spring事务 数据库事务 事务的ACID A, Atomicity 事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行 C, Consistency 几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致 I, Isolation 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的 D, Durability 对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 事务的一些问题 脏读：读取到了未提交事务的数据，比如未提交读就可能会产生这种数据 不可重复读：在同一个事务里两次读取的数据不一样，因为在两次读取的过程中，另一个事务提交改变了该值(update操作)。未提交读，已提交读又称为不可重复读，会产生这种情况。 幻读：与不可重复读类似，幻读是两次查询的行个数不一样(针对的是insert操作)。幻读针对的是多行，不可重复读针对的是一行或者一个数据。 4种隔离级别 MySQL 四种隔离级别及测试 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。 Read committed (读已提交)：可避免脏读的发生。 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。 Repeatable read (可重复读，MySQL默认)：可避免脏读、不可重复读的发生。 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。 Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable read(MySQL默认) × × √ Serializable × × × √: 可能出现 ×: 不会出现 Spring Transaction Management Transaction Management Doc The most important concepts to grasp with regard to the Spring Framework’s declarative transaction support are that this support is enabled via AOP proxies and that the transactional advice is driven by metadata (currently XML- or annotation-based). The combination of AOP with transactional metadata yields an AOP proxy that uses a TransactionInterceptor in conjunction with an appropriate PlatformTransactionManager implementation to drive transactions around method invocations. （Spring的声明式事务的支持依靠：AOP代理和transactional增强器(通过xml或者annotation配置的增强器)） 回顾Jdbc事务配置和使用 @EnableTransactionManagement @ComponentScan(\"com.test\") @Configuration public class TxConfig { @Bean public DataSource dataSource(){ DriverManagerDataSource ds = new DriverManagerDataSource (); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/test\"); ds.setUsername(\"root\"); ds.setPassword(\"\"); return ds; } @Bean public JdbcTemplate jdbcTemplate(){ JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource()); return jdbcTemplate; } /** * 注册事务管理器到容器中 */ @Bean public PlatformTransactionManager transactionManager(){ return new DataSourceTransactionManager(dataSource()); } } 测试使用,方法上加上@Transactional @Transactional(rollbackFor = Exception.class) public Boolean insertAUser(TbUser tbUser){ String sql = \"insert into t_user(sno, name, password) values(?,?,?)\"; int cnt = jdbcTemplate.update(sql, tbUser.getSno(), tbUser.getName(), tbUser.getPassword()); int arr[] = {1,2}; int c = arr[2]; return cnt > 0 ? true : false; } Spring事务抽象 Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 PlatformTransactionManager : 事务管理器(用来管理事务，包含事务的提交，回滚) TransactionDefinition : 事务定义信息(隔离，传播，超时，只读) TransactionStatus : 事务具体运行状态 Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，各自实现具体细节。 PlatformTransactionManager(事务管理器接口) 三个抽象方法： 获取事务状态 提交事务 回滚事务 public interface PlatformTransactionManager { /** * Return a currently active transaction or create a new one, according to * the specified propagation behavior. * Note that parameters like isolation level or timeout will only be applied * to new transactions, and thus be ignored when participating in active ones. * Furthermore, not all transaction definition settings will be supported * by every transaction manager: A proper transaction manager implementation * should throw an exception when unsupported settings are encountered. * An exception to the above rule is the read-only flag, which should be * ignored if no explicit read-only mode is supported. Essentially, the * read-only flag is just a hint for potential optimization. * @param definition the TransactionDefinition instance (can be {@code null} for defaults), * describing propagation behavior, isolation level, timeout etc. * @return transaction status object representing the new or current transaction * @throws TransactionException in case of lookup, creation, or system errors * @throws IllegalTransactionStateException if the given transaction definition * cannot be executed (for example, if a currently active transaction is in * conflict with the specified propagation behavior) * @see TransactionDefinition#getPropagationBehavior * @see TransactionDefinition#getIsolationLevel * @see TransactionDefinition#getTimeout * @see TransactionDefinition#isReadOnly */ TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; /** * Commit the given transaction, with regard to its status. If the transaction * has been marked rollback-only programmatically, perform a rollback. * If the transaction wasn't a new one, omit the commit for proper * participation in the surrounding transaction. If a previous transaction * has been suspended to be able to create a new one, resume the previous * transaction after committing the new one. * Note that when the commit call completes, no matter if normally or * throwing an exception, the transaction must be fully completed and * cleaned up. No rollback call should be expected in such a case. * If this method throws an exception other than a TransactionException, * then some before-commit error caused the commit attempt to fail. For * example, an O/R Mapping tool might have tried to flush changes to the * database right before commit, with the resulting DataAccessException * causing the transaction to fail. The original exception will be * propagated to the caller of this commit method in such a case. * @param status object returned by the {@code getTransaction} method * @throws UnexpectedRollbackException in case of an unexpected rollback * that the transaction coordinator initiated * @throws HeuristicCompletionException in case of a transaction failure * caused by a heuristic decision on the side of the transaction coordinator * @throws TransactionSystemException in case of commit or system errors * (typically caused by fundamental resource failures) * @throws IllegalTransactionStateException if the given transaction * is already completed (that is, committed or rolled back) * @see TransactionStatus#setRollbackOnly */ void commit(TransactionStatus status) throws TransactionException; /** * Perform a rollback of the given transaction. * If the transaction wasn't a new one, just set it rollback-only for proper * participation in the surrounding transaction. If a previous transaction * has been suspended to be able to create a new one, resume the previous * transaction after rolling back the new one. * Do not call rollback on a transaction if commit threw an exception. * The transaction will already have been completed and cleaned up when commit * returns, even in case of a commit exception. Consequently, a rollback call * after commit failure will lead to an IllegalTransactionStateException. * @param status object returned by the {@code getTransaction} method * @throws TransactionSystemException in case of rollback or system errors * (typically caused by fundamental resource failures) * @throws IllegalTransactionStateException if the given transaction * is already completed (that is, committed or rolled back) */ void rollback(TransactionStatus status) throws TransactionException; } DataSourceTransactionManager 实现 PlatformTransactionManager DataSourceTransactionManager 针对 JdbcTemplate,Mybatis 事务，使用Connection进行事务控制 开启事务：connection.setAutoCommit(false) 提交事务：connection.commit 回滚事务：connection.rollback() TransactionDefinition(事务定义信息接口) 事务的定义信息（隔离，传播，超时，只读） /** * Interface that defines Spring-compliant transaction properties. * Based on the propagation behavior definitions analogous to EJB CMT attributes. * * Note that isolation level and timeout settings will not get applied unless * an actual new transaction gets started. As only {@link #PROPAGATION_REQUIRED}, * {@link #PROPAGATION_REQUIRES_NEW} and {@link #PROPAGATION_NESTED} can cause * that, it usually doesn't make sense to specify those settings in other cases. * Furthermore, be aware that not all transaction managers will support those * advanced features and thus might throw corresponding exceptions when given * non-default values. * * The {@link #isReadOnly() read-only flag} applies to any transaction context, * whether backed by an actual resource transaction or operating non-transactionally * at the resource level. In the latter case, the flag will only apply to managed * resources within the application, such as a Hibernate {@code Session}. * * @author Juergen Hoeller * @since 08.05.2003 * @see PlatformTransactionManager#getTransaction(TransactionDefinition) * @see org.springframework.transaction.support.DefaultTransactionDefinition * @see org.springframework.transaction.interceptor.TransactionAttribute */ public interface TransactionDefinition { int getPropagationBehavior(); // 返回事务的传播行为 int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据 int getTimeout(); // 返回事务必须在多少秒内完成 boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的 } TransactionStatus(事务运行状态接口) public interface TransactionStatus{ boolean isNewTransaction(); // 是否是新的事物 boolean hasSavepoint(); // 是否有恢复点 void setRollbackOnly(); // 设置为只回滚 boolean isRollbackOnly(); // 是否为只回滚 boolean isCompleted; // 是否已完成 } @EnableTransactionManagement @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(TransactionManagementConfigurationSelector.class) public @interface EnableTransactionManagement { 利用TransactionManagementConfigurationSelector导入组件，默认增强器模式是PROXY，导入了AutoProxyRegistrar和ProxyTransactionManagementConfiguration` 两个组件 public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector { /** * Returns {@link ProxyTransactionManagementConfiguration} or * {@code AspectJ(Jta)TransactionManagementConfiguration} for {@code PROXY} * and {@code ASPECTJ} values of {@link EnableTransactionManagement#mode()}, * respectively. */ @Override protected String[] selectImports(AdviceMode adviceMode) { switch (adviceMode) { case PROXY: return new String[] {AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()}; case ASPECTJ: return new String[] {determineTransactionAspectClass()}; default: return null; } } private String determineTransactionAspectClass() { return (ClassUtils.isPresent(\"javax.transaction.Transactional\", getClass().getClassLoader()) ? TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME : TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME); } } AutoProxyRegistrar 注册一个InfrastructureAdvisorAutoProxyCreator组件 @Nullable public static BeanDefinition registerAutoProxyCreatorIfNecessary( BeanDefinitionRegistry registry, @Nullable Object source) { return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source); } 查看InfrastructureAdvisorAutoProxyCreator类图，其是一个BeanPostProcessor ProxyTransactionManagementConfiguration(注册事务增强器) 在容器中注册事务增强器 1. 事务注解和解析 2. 注册了事务拦截器`TransactionInterceptor` 保存事务管理器，事务属性信息,是一个`MethodInterceptor`在目标方法执行的时候 执行拦截器链, 其中事务拦截器操作如下 1. 获取事务相关的属性 2. 获取PlatformTransactionManager 3. 执行目标方法 a. 如果异常，获取到事务管理器，利用事务管理回滚操作 b. 如果正常，利用事务管理器，正常提交事务 TransactionInterceptor @Override @Nullable public Object invoke(MethodInvocation invocation) throws Throwable { // Work out the target class: may be {@code null}. // The TransactionAttributeSource should be passed the target class // as well as the method, which may be from an interface. Class targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); // Adapt to TransactionAspectSupport's invokeWithinTransaction... return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed); } invokeWithinTransaction方法对目标对象方法进行拦截 /** * General delegate for around-advice-based subclasses, delegating to several other template * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager} * as well as regular {@link PlatformTransactionManager} implementations. * @param method the Method being invoked * @param targetClass the target class that we're invoking the method on * @param invocation the callback to use for proceeding with the target invocation * @return the return value of the method, if any * @throws Throwable propagated from the target invocation */ @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class targetClass, final InvocationCallback invocation) throws Throwable { // If the transaction attribute is null, the method is non-transactional. TransactionAttributeSource tas = getTransactionAttributeSource(); final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); final PlatformTransactionManager tm = determineTransactionManager(txAttr); final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) { // Standard transaction demarcation with getTransaction and commit/rollback calls. TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try { // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // target invocation exception completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } commitTransactionAfterReturning(txInfo); return retVal; } else { final ThrowableHolder throwableHolder = new ThrowableHolder(); // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in. try { Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -> { TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status); try { return invocation.proceedWithInvocation(); } catch (Throwable ex) { if (txAttr.rollbackOn(ex)) { // A RuntimeException: will lead to a rollback. if (ex instanceof RuntimeException) { throw (RuntimeException) ex; } else { throw new ThrowableHolderException(ex); } } else { // A normal return value: will lead to a commit. throwableHolder.throwable = ex; return null; } } finally { cleanupTransactionInfo(txInfo); } }); // Check result state: It might indicate a Throwable to rethrow. if (throwableHolder.throwable != null) { throw throwableHolder.throwable; } return result; } catch (ThrowableHolderException ex) { throw ex.getCause(); } catch (TransactionSystemException ex2) { if (throwableHolder.throwable != null) { logger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable); ex2.initApplicationException(throwableHolder.throwable); } throw ex2; } catch (Throwable ex2) { if (throwableHolder.throwable != null) { logger.error(\"Application exception overridden by commit exception\", throwableHolder.throwable); } throw ex2; } } } 处理异常：commit or roll back /** * Handle a throwable, completing the transaction. * We may commit or roll back, depending on the configuration. * @param txInfo information about the current transaction * @param ex throwable encountered */ protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) { if (txInfo != null && txInfo.getTransactionStatus() != null) { if (logger.isTraceEnabled()) { logger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() + \"] after exception: \" + ex); } if (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) { try { txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus()); } catch (TransactionSystemException ex2) { logger.error(\"Application exception overridden by rollback exception\", ex); ex2.initApplicationException(ex); throw ex2; } catch (RuntimeException | Error ex2) { logger.error(\"Application exception overridden by rollback exception\", ex); throw ex2; } } else { // We don't roll back on this exception. // Will still roll back if TransactionStatus.isRollbackOnly() is true. try { txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()); } catch (TransactionSystemException ex2) { logger.error(\"Application exception overridden by commit exception\", ex); ex2.initApplicationException(ex); throw ex2; } catch (RuntimeException | Error ex2) { logger.error(\"Application exception overridden by commit exception\", ex); throw ex2; } } } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-16 18:44:43 "},"doc/bean/transaction_annotation.html":{"url":"doc/bean/transaction_annotation.html","title":"@Transactional","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 @Transactional 事务的传播特性 什么是事务的传播特性？ Spring给出的7种事务的传播类型 PROPAGATION_REQUIRED PROPAGATION_SUPPORTS Spring的5种事务隔离级别 rollbackFor属性 @Transactional 事务的传播特性 什么是事务的传播特性？ 指的是当一个事务方法被另一个事务方法调用时，这个事务方法该如何进行？ @Transactional public void A(){ // xx B(); C(); // xx // 出现异常 } @Transactional public void B(){ // xx // 出现异常 } @Transactional public void C(){ // xx // 出现异常 } 如上：事务A内部有事务B,事务C；如果A异常了，那么B,C怎么处理事务；如果B，C事务异常，那么事务A怎么处理？ Spring给出的7种事务的传播类型 /** * Enumeration that represents transaction propagation behaviors for use * with the {@link Transactional} annotation, corresponding to the * {@link TransactionDefinition} interface. * * @author Colin Sampaleanu * @author Juergen Hoeller * @since 1.2 */ public enum Propagation { /** * * Support a current transaction, create a new one if none exists. * Analogous to EJB transaction attribute of the same name. * This is the default setting of a transaction annotation. */ REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED), /** * Support a current transaction, execute non-transactionally if none exists. * Analogous to EJB transaction attribute of the same name. * Note: For transaction managers with transaction synchronization, * PROPAGATION_SUPPORTS is slightly different from no transaction at all, * as it defines a transaction scope that synchronization will apply for. * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc) * will be shared for the entire specified scope. Note that this depends on * the actual synchronization configuration of the transaction manager. * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization */ SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS), /** * Support a current transaction, throw an exception if none exists. * Analogous to EJB transaction attribute of the same name. */ MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY), /** * Create a new transaction, and suspend the current transaction if one exists. * Analogous to the EJB transaction attribute of the same name. * NOTE: Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available it to it (which is server-specific in standard Java EE). * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */ REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW), /** * Execute non-transactionally, suspend the current transaction if one exists. * Analogous to EJB transaction attribute of the same name. * NOTE: Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available it to it (which is server-specific in standard Java EE). * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */ NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED), /** * Execute non-transactionally, throw an exception if a transaction exists. * Analogous to EJB transaction attribute of the same name. */ NEVER(TransactionDefinition.PROPAGATION_NEVER), /** * Execute within a nested transaction if a current transaction exists, * behave like PROPAGATION_REQUIRED else. There is no analogous feature in EJB. * Note: Actual creation of a nested transaction will only work on specific * transaction managers. Out of the box, this only applies to the JDBC * DataSourceTransactionManager when working on a JDBC 3.0 driver. * Some JTA providers might support nested transactions as well. * @see org.springframework.jdbc.datasource.DataSourceTransactionManager */ NESTED(TransactionDefinition.PROPAGATION_NESTED); private final int value; Propagation(int value) { this.value = value; } public int value() { return this.value; } } 传播属性 描述 required(默认) 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。 requires_new 不管当前是否已经存在事务，都会新建一个事务；开启的事务相互独立，互不干扰。 Mandatory 支持当前事务，如果当前没有事务，就抛出异常。 Never 以非事务方式执行，如果当前存在事务，则抛出异常。 Not_supports 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 Supports 支持当前事务，如果当前没有事务，就以非事务方式执行。 Nested 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。 PROPAGATION_REQUIRED @Transactional(propagation = Propagation.REQUIRED) public void methodA() { methodB(); // do something } @Transactional(propagation = Propagation.REQUIRED) public void methodB() { // do something } 单独调用methodB方法时，因为当前上下文不存在事务，所以会开启一个新的事务。 调用methodA方法时，因为当前上下文不存在事务，所以会开启一个新的事务。当执行到methodB时，methodB发现当前上下文有事务，因此就加入到当前事务中来。 PROPAGATION_SUPPORTS @Transactional(propagation = Propagation.REQUIRED) public void methodA() { methodB(); // do something } // 事务属性为SUPPORTS @Transactional(propagation = Propagation.SUPPORTS) public void methodB() { // do something } 单纯的调用methodB时，methodB方法是非事务的执行的。 当调用methodA时,methodB则加入了methodA的事务中,事务地执行。 Spring的5种事务隔离级别 /** * Enumeration that represents transaction isolation levels for use * with the {@link Transactional} annotation, corresponding to the * {@link TransactionDefinition} interface. * * @author Colin Sampaleanu * @author Juergen Hoeller * @since 1.2 */ public enum Isolation { /** * 这是一个PlatformTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别 * * Use the default isolation level of the underlying datastore. * All other levels correspond to the JDBC isolation levels. * @see java.sql.Connection */ DEFAULT(TransactionDefinition.ISOLATION_DEFAULT), /** * A constant indicating that dirty reads, non-repeatable reads and phantom reads * can occur. This level allows a row changed by one transaction to be read by * another transaction before any changes in that row have been committed * (a \"dirty read\"). If any of the changes are rolled back, the second * transaction will have retrieved an invalid row. * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED */ READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED), /** * A constant indicating that dirty reads are prevented; non-repeatable reads * and phantom reads can occur. This level only prohibits a transaction * from reading a row with uncommitted changes in it. * @see java.sql.Connection#TRANSACTION_READ_COMMITTED */ READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED), /** * A constant indicating that dirty reads and non-repeatable reads are * prevented; phantom reads can occur. This level prohibits a transaction * from reading a row with uncommitted changes in it, and it also prohibits * the situation where one transaction reads a row, a second transaction * alters the row, and the first transaction rereads the row, getting * different values the second time (a \"non-repeatable read\"). * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ */ REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ), /** * A constant indicating that dirty reads, non-repeatable reads and phantom * reads are prevented. This level includes the prohibitions in * {@code ISOLATION_REPEATABLE_READ} and further prohibits the situation * where one transaction reads all rows that satisfy a {@code WHERE} * condition, a second transaction inserts a row that satisfies that * {@code WHERE} condition, and the first transaction rereads for the * same condition, retrieving the additional \"phantom\" row in the second read. * @see java.sql.Connection#TRANSACTION_SERIALIZABLE */ SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE); private final int value; Isolation(int value) { this.value = value; } public int value() { return this.value; } } rollbackFor属性 /** * Defines zero (0) or more exception {@link Class classes}, which must be * subclasses of {@link Throwable}, indicating which exception types must cause * a transaction rollback. * By default, a transaction will be rolling back on {@link RuntimeException} * and {@link Error} but not on checked exceptions (business exceptions). See * {@link org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)} * for a detailed explanation. * This is the preferred way to construct a rollback rule (in contrast to * {@link #rollbackForClassName}), matching the exception class and its subclasses. * Similar to {@link org.springframework.transaction.interceptor.RollbackRuleAttribute#RollbackRuleAttribute(Class clazz)}. * @see #rollbackForClassName * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable) */ Class[] rollbackFor() default {}; roll back默认是Error和RuntimeException eg1: 不加rollbackFor属性，抛出RuntimeException，正常回滚 @Transactional eg2: 不加rollbackFor属性，抛出IOException，不回滚 @Transactional eg3: 加上rollbackFor = Exception.class，抛出IOException，正常回滚 @Transactional(rollbackFor = Exception.class) eg4: 不加rollbackFor属性，抛出OutOfMemoryError，正常回滚 @Transactional() throw new OutOfMemoryError(); eg5: 加上rollbackFor = Exception.class，抛出OutOfMemoryError，正常回滚 @Transactional(rollbackFor = Exception.class) throw new OutOfMemoryError(); Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-11-29 13:15:27 "},"doc/mybatis.html":{"url":"doc/mybatis.html","title":"MyBatis手写","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 MyBatis ORM概念 Jdbc传统做法 Mybatis ORM框架 自己实现MyBatis Session的getMapper方法，生产Mapper代理对象 Mapper方法的执行利用反射(1.解析sql,2.jdbc执行) 利用FactoryBean获取成千上万的不同Mapper对象 ImportBeanDefinitionRegistrar 注册FactoryBean到Spring中 支持MapperScan注解 测试 MyBatis ORM概念 对象关系映射（Object Relational Mapping，简称ORM）是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。 这也同时暗示着额外的执行开销；然而，如果ORM作为一种中间件实现，则会有很多机会做优化，而这些在手写的持久层并不存在。 更重要的是用于控制转换的元数据需要提供和管理；但是同样，这些花费要比维护手写的方案要少；而且就算是遵守ODMG规范的对象数据库依然需要类级别的元数据。 Jdbc传统做法 导入jdbc驱动包 通过DriverManager注册驱动 创建连接 创建statement 执行curd sql语句 操作结果集 关闭连接 Mybatis ORM框架 mybatis 官方文档 mybatis 结合 Spring 官方文档 MyBatis原理：Jdk动态代理产生Mapper的代理对象 解析sql语句 执行sql(数据库连接) 结合Spring:mybatis产生的代理对象怎么放到Spring容器中 自己产生的对象(自己new,而不是spring new出来的)怎么交给Spring管理？ 单个bean: @Bean 成千上万的bean: @FactoryBean（mybatis中的MapperFactoryBean） 用spring的beanFactory注册bean: beanFactory.registerSingleton(Object) 自己实现MyBatis Session的getMapper方法，生产Mapper代理对象 package com.test.mybatis; import java.lang.reflect.Proxy; /** * @Author mubi * @Date 2020/7/11 13:45 */ public class DbSession { public static Object getMapper(Class clazz) { Class[] clazzs = new Class[]{clazz}; // 类加载器，被代理类，InvocationHandler方法改变增强 Object object = Proxy.newProxyInstance(DbSession.class.getClassLoader(), clazzs, new DbInvocationHandler()); return object; } } Mapper方法的执行利用反射(1.解析sql,2.jdbc执行) Mapper类 public interface UserMapper { /** * select 映射 * @param id * @return */ @Select(\"SELECT * FROM t_user WHERE id = #{id}\") TbUser selectUserById(int id); } Mapper类动态代理:方法(解析sql, 执行jdbc, 返回结果) package com.test.mybatis; import com.test.entity.TbUser; import org.apache.ibatis.annotations.Select; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; /** * @Author mubi * @Date 2020/7/11 13:45 */ public class DbInvocationHandler implements InvocationHandler { /** * mapper 里面的方法，逻辑是一个 * 1. 解析sql * 2. 执行sql（jdbc连接) */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 1. parse sql Select annotation = method.getAnnotation(Select.class); String sql = annotation.value()[0]; Object val = args[0]; String parseSql = sql.replace(\"#{id}\", String.valueOf(val)); System.out.println(\"parse sql:\" + parseSql); // 2. execute sql return exeSql(parseSql); } static TbUser exeSql(String sql) { Connection conn = null; Statement stmt = null; Integer id = 0; String name = null; String sno = null; String password = null; try { //STEP 1: Register JDBC driver Class.forName(\"com.mysql.jdbc.Driver\"); //STEP 2: Open a connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"\"); //STEP 3: Execute a query stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql); //STEP 4: Get results while (rs.next()) { id = Integer.valueOf(rs.getString(\"id\")); sno = rs.getString(\"sno\"); name = rs.getString(\"name\"); password = rs.getString(\"password\"); break; } rs.close(); } catch (Exception e) { }//end try return new TbUser(id, sno, name, password); } } 利用FactoryBean获取成千上万的不同Mapper对象 package com.test.mybatis; import org.springframework.beans.factory.FactoryBean; /** * @Author mubi * @Date 2020/7/11 13:45 * FactoryBean是一个特殊bean: 自己 + 产生的bean * Spring能获取到该bean, 和该bean产生的bean */ public class DbMapperFactoryBean implements FactoryBean { Class mapperInterface; @Override public Object getObject() throws Exception { Object object = DbSession.getMapper(mapperInterface); return object; } @Override public Class getObjectType() { return mapperInterface; } } ImportBeanDefinitionRegistrar 注册FactoryBean到Spring中 package com.test.mybatis; import org.springframework.beans.factory.support.AbstractBeanDefinition; import org.springframework.beans.factory.support.BeanDefinitionBuilder; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.context.annotation.ImportBeanDefinitionRegistrar; import org.springframework.core.type.AnnotationMetadata; /** * @Author mubi * @Date 2020/7/11 13:45 * ImportBeanDefinitionRegistrar 动态的注册自己写的Bean, 这里是`DbMapperFactoryBean` */ public class DbImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(DbMapperFactoryBean.class); AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); // 这里可以利用反射，for循环mapper package下的所有Mapper类，然后添加所有 beanDefinition.getConstructorArgumentValues() .addGenericArgumentValue(\"com.test.mapper.UserMapper\"); registry.registerBeanDefinition(\"dbMapperFactoryBean\", beanDefinition); } } 支持MapperScan注解 package com.test.mybatis; import org.springframework.context.annotation.Import; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) @Import(DbImportBeanDefinitionRegistrar.class) public @interface DbMapperScan{ } 测试 static void testSelfMybatis(){ UserMapper userMapper = (UserMapper) DbSession.getMapper(UserMapper.class); logger.info(\"selectTbUserById:\" + userMapper.selectUserById(1)); } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-26 13:49:41 "},"doc/mybatis_source.html":{"url":"doc/mybatis_source.html","title":"MyBatis源码分析","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 MyBatis 源码 SpringBoot项目如何使用mybatis的 使用很简单;原理呢? MyBatis 源码 SqlSession 通过会话工厂创建sqlSession即会话，程序员通过sqlsession会话接口对数据库进行增删改查操作。 MappedStatement 它是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个select\\insert\\update\\delete标签对应一个Mapped Statement对象，select\\insert\\update\\delete标签的id即是Mapped statement的id。 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过MappedStatement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过MappedStatement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 Executor MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护 StatementHandler 装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。 SpringBoot项目如何使用mybatis的 一个常规的springboot项目整合mybatis如下 项目启动类加上了@MapperScan @SpringBootApplication @MapperScan(\"com.example.demo.repository\") @EnableScheduling public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 有model类，Mapper接口和对应的xml文件，xml文件例子如下 and ${criterion.condition} and ${criterion.condition} #{criterion.value} and ${criterion.condition} #{criterion.value} and #{criterion.secondValue} and ${criterion.condition} #{listItem} and ${criterion.condition} and ${criterion.condition} #{criterion.value} and ${criterion.condition} #{criterion.value} and #{criterion.secondValue} and ${criterion.condition} #{listItem} id, userID, password, name, phone, address select distinct from tb_user order by ${orderByClause} select from tb_user where id = #{id,jdbcType=INTEGER} delete from tb_user where id = #{id,jdbcType=INTEGER} delete from tb_user insert into tb_user (id, userID, password, name, phone, address ) values (#{id,jdbcType=INTEGER}, #{userid,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, #{name,jdbcType=VARCHAR}, #{phone,jdbcType=VARCHAR}, #{address,jdbcType=VARCHAR} ) insert into tb_user id, userID, password, name, phone, address, #{id,jdbcType=INTEGER}, #{userid,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, #{name,jdbcType=VARCHAR}, #{phone,jdbcType=VARCHAR}, #{address,jdbcType=VARCHAR}, select count(*) from tb_user update tb_user id = #{record.id,jdbcType=INTEGER}, userID = #{record.userid,jdbcType=VARCHAR}, password = #{record.password,jdbcType=VARCHAR}, name = #{record.name,jdbcType=VARCHAR}, phone = #{record.phone,jdbcType=VARCHAR}, address = #{record.address,jdbcType=VARCHAR}, update tb_user set id = #{record.id,jdbcType=INTEGER}, userID = #{record.userid,jdbcType=VARCHAR}, password = #{record.password,jdbcType=VARCHAR}, name = #{record.name,jdbcType=VARCHAR}, phone = #{record.phone,jdbcType=VARCHAR}, address = #{record.address,jdbcType=VARCHAR} update tb_user userID = #{userid,jdbcType=VARCHAR}, password = #{password,jdbcType=VARCHAR}, name = #{name,jdbcType=VARCHAR}, phone = #{phone,jdbcType=VARCHAR}, address = #{address,jdbcType=VARCHAR}, where id = #{id,jdbcType=INTEGER} update tb_user set userID = #{userid,jdbcType=VARCHAR}, password = #{password,jdbcType=VARCHAR}, name = #{name,jdbcType=VARCHAR}, phone = #{phone,jdbcType=VARCHAR}, address = #{address,jdbcType=VARCHAR} where id = #{id,jdbcType=INTEGER} select distinct from tb_user order by ${orderByClause} 通常是使用mybatis-generator来自动生成的 配置文件要加上数据库配置，也可以自定义Datasource, 一般项目会加上各种starter spring.datasource.driverClassName=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;autoReconnectForPools=true&amp;useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.username=root spring.datasource.password=123456 compile('org.springframework.boot:spring-boot-starter-jdbc') compile('org.springframework.boot:spring-boot-starter-web') compile('org.mybatis.spring.boot:mybatis-spring-boot-starter:1.3.2') 使用很简单;原理呢? 通过学习@Configuration,到学习ConfigurationClassPostProcessor这个bfpp，再到@MapperScan的学习到mybatis的org.mybatis.spring.mapper.MapperScannerConfigurer的bfpp，这样mybatis是将Mapper的BeanDefinition注册到spring容器中了 通过springboot的starter的学习，可以知道datasource是如何注入的(通过@Import注解 + 实现ImportSelector接口的方式向IOC容器里注入Bean) Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-10-17 16:52:52 "},"doc/springboot.html":{"url":"doc/springboot.html","title":"SpringMvc & SpringBoot","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 SpringBoot MVC Spring MVC 原理 spring mvc处理流程 请求是怎么由@Controller的方法处理的? @Controller处理架构图 debug打点,访问http://localhost:8098/boot/json.do 请求统一交给DispatchServlet分发处理 从Spring加载好的HandlerExecutionChain找到对应的Handler的适配器HandlerAdapter处理请求 RequestMappingHandlerAdapter:invokeHandlerMethod(request, response, handlerMethod)完成处理 仍然是利用反射实现@RequestMapping方法的调用 附：HandlerInterceptor Filter过滤器的生命周期 过滤器 和 拦截器 SpringBoot spring web 官方文档 内嵌容器原理 零配置 MVC 在JavaWeb程序中，MVC框架模式是经常用到的，举一个Web程序的结构可以更好的理解MVC的理念 V：View视图，Web程序中指用户可以看到的并可以与之进行数据交互的界面，比如一个Html网页界面，或者某些客户端的界面，在前面讲过，MVC可以为程序处理很多不同的视图，用户在视图中进行输出数据以及一系列操作，注意：视图中不会发生数据的处理操作。 M：Model模型：进行所有数据的处理工作，模型返回的数据是中立的，和数据格式无关，一个模型可以为多个视图来提供数据，所以模型的代码重复性比较低 C：Controller控制器：负责接受用户的输入，并且调用模型和视图去完成用户的需求，控制器不会输出也不会做出任何处理，只会接受请求并调用模型构件去处理用户的请求，然后在确定用哪个视图去显示返回的数据 Spring MVC采用了松散耦合的可插拔组件结构，比其他的MVC框架更具有灵活性和扩展性，Spring MVC通过使用一套注解，使一个Java类成为前端控制器(Controller)，不需要实现任何接口，同时，Spring MVC支持RES形式的URL请求，除此之外，Spring MVC在在数据绑定、视图解析、本地化处理及静态资源处理上都有许多不俗的表现 Spring MVC围绕DispatcherServlet(前端控制器)为中心展开，DispatcherServlet(前端控制器)是Spring MVC的中枢，和MVC的思想一样，它负责从视图获取用户请求并且分派给相应的处理器处理，并决定用哪个视图去把数据呈现给给用户 Spring MVC 原理 Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. Spring MVC 构建在Servlet API基础上实现了MVC设计模式的web框架 DispatcherServlet uses Spring configuration to discover the delegate components it needs for request mapping, view resolution, exception handling public class MyWebApplicationInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext servletCxt) { // Load Spring web application configuration AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext(); ac.register(AppConfig.class); ac.refresh(); // Create and register the DispatcherServlet DispatcherServlet servlet = new DispatcherServlet(ac); ServletRegistration.Dynamic registration = servletCxt.addServlet(\"app\", servlet); registration.setLoadOnStartup(1); registration.addMapping(\"/app/*\"); } } spring mvc处理流程 第一步：发起请求到前端控制器(DispatcherServlet) 第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找） 第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略 第四步：前端控制器调用处理器适配器去执行Handler 第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler 第六步：Handler执行完成给适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view） 第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 第九步：视图解析器向前端控制器返回View 第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 第十一步：前端控制器向用户响应结果 请求是怎么由@Controller的方法处理的? @Controller处理架构图 debug打点,访问http://localhost:8098/boot/json.do @Controller public class TestController { private static final Log logger = LogFactory.getLog(TestController.class); @GetMapping(\"/test.do\") @ResponseBody public String test(HttpServletRequest request, HttpServletResponse response){ String uri = request.getRequestURI(); logger.info(\"TestController test\"); return uri; } @GetMapping(\"/json.do\") @ResponseBody public Map getJson(HttpServletRequest request, HttpServletResponse response){ Map mp = new HashMap<>(2); mp.put(\"key\", \"val\"); return mp; } } 请求统一交给DispatchServlet分发处理 从Spring加载好的HandlerExecutionChain找到对应的Handler的适配器HandlerAdapter处理请求 spring mvc中，在 web.xml 文件中配置 url 映射配置，通俗来讲就是请求的 URL 怎么能被 SpringMVC 识别，从而去执行我们编写好的 Handler；Spring boot中加载了@Controller下各个Mapping注解bean 然后 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); RequestMappingHandlerAdapter:invokeHandlerMethod(request, response, handlerMethod)完成处理 RequestMappingHandlerAdapter继承的抽象类AbstractHandlerMethodAdapter定义了抽象handle方法，最后会走到org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean { request中包括了处理请求的网络连接的tomcat连接器情况 要执行具体的请求业务逻辑，先new出来了一个ServletInvocableHandlerMethod ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); 仍然是利用反射实现@RequestMapping方法的调用 invocableMethod.invokeAndHandle(webRequest, mavContainer); org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest @Nullable public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) { logger.trace(\"Arguments: \" + Arrays.toString(args)); } return doInvoke(args); } org.springframework.web.method.support.InvocableHandlerMethod#doInvoke getBridgedMethod().invoke(getBean(), args); 返回结果交给了returnValueHandlers /** * Iterate over registered {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers} and invoke the one that supports it. * @throws IllegalStateException if no suitable {@link HandlerMethodReturnValueHandler} is found. */ @Override public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception { HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) { throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName()); } handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); } 最后仍然是HTTPServletResponse处理返回，并应用Converters操作 附：HandlerInterceptor Spring MVC提供了Interceptor拦截器机制，类似于Servlet中的Filter过滤器，用于拦截用户的请求并做出相应的处理。比如通过拦截器来进行用户权限验证，或者用来判断用户是否已经登录。Spring MVC拦截器是可插拔式的设计，需要某一功能拦截器，只需在配置文件中应用该拦截器即可；如果不需要这个功能拦截器，只需在配置文件中取消应用该拦截器。 拦截器是 AOP 的一种实现策略，用于在某个方法或字段被访问前对它进行拦截，然后在其之前或之后加上某些操作。同 filter 一样，interceptor 也是链式调用。每个 interceptor 的调用会依据它的声明顺序依次执行。一般来说拦截器可以用于以下方面 ： 日志记录 ：几率请求信息的日志，以便进行信息监控、信息统计等等 权限检查 ：对用户的访问权限，认证，或授权等进行检查 性能监控 ：通过拦截器在进入处理器前后分别记录开始时间和结束时间，从而得到请求的处理时间 通用行为 ：读取 cookie 得到用户信息并将用户对象放入请求头中，从而方便后续流程使用 在Spring MVC中定义一个拦截器有两种方法： 实现HandlerInterceptor接口 实现WebRequestInterceptor接口 // 1. 定义拦截器 import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class UrlInterceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(UrlInterceptor.class); private static final String GET_ALL = \"getAll\"; private static final String GET_HEADER = \"getHeader\"; /** * 进入Controller层之前拦截请求，默认是拦截所有请求 * @param httpServletRequest request * @param httpServletResponse response * @param o object * @return 是否拦截当前请求，true表示拦截当前请求，false表示不拦截当前请求 * @throws Exception 可能出现的异常 */ @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { logger.info(\"go into preHandle method ... \"); String requestURI = httpServletRequest.getRequestURI(); if (requestURI.contains(GET_ALL)) { return true; } if (requestURI.contains(GET_HEADER)) { httpServletResponse.sendRedirect(\"/user/redirect\"); } return true; } /** * 处理完请求后但还未渲染试图之前进行的操作 * @param httpServletRequest request * @param httpServletResponse response * @param o object * @param modelAndView mv * @throws Exception E */ @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { logger.info(\"go into postHandle ... \"); } /** * 视图渲染后但还未返回到客户端时的操作 * @param httpServletRequest request * @param httpServletResponse response * @param o object * @param e exception * @throws Exception */ @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { logger.info(\"go into afterCompletion ... \"); } } // 2. 注册拦截器 import com.glodon.tot.interceptor.UrlInterceptor; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MvcConfig implements WebMvcConfigurer { /** * 注册配置的拦截器 * @param registry 拦截器注册器 */ @Override public void addInterceptors(InterceptorRegistry registry) { // 这里的拦截器是new出来的，在Spring框架中可以交给IOC进行依赖注入，直接使用@Autowired注入 registry.addInterceptor(new UrlInterceptor()); } } Filter过滤器的生命周期 过滤器 Filter，是在 Servlet 规范中定义的，是 Servlet 容器支持的，该接口定义在 javax.servlet包下，主要是在客户端请求(HttpServletRequest)进行预处理，以及对服务器响应(HttpServletResponse)进行后处理。 Filter（过滤器）生命周期各方法执行顺序 服务器启动，首先执行构造方法和init方法（这两个方法只执行一次） 当有匹配过滤条件的请求时执行doFilter方法（该方法可以执行多次） 服务器正常关闭的时候，或者该Filter类重新加载的时候会执行destroy方法（该方法只执行一次） 当启动服务器时init方法马上执行了（在还没打开网页前已经执行了） 在过滤时(网页刷新时)才运行doFilter方法 当关掉服务器时执行destroy方法，就是当你点击关闭服务器是，就在执行了，伴随关闭一起执行 过滤器 和 拦截器 作用域差异：Filter是Servlet规范中规定的，只能用于WEB中，拦截器既可以用于WEB，也可以用于Application、Swing中（即过滤器是依赖于Servlet容器的，和它类似的还有Servlet中的监听器同样依赖该容器，而拦截器则不依赖它）； 规范差异：Filter是Servlet规范中定义的，是Servlet容器支持的，而拦截器是Spring容器内的，是Spring框架支持的； 资源差异：拦截器是Spring的一个组件，归Spring管理配置在Spring的文件中，可以使用Spring内的任何资源、对象（可以粗浅的认为是IOC容器中的Bean对象），而Filter则不能使用访问这些资源； 深度差异：Filter只在Servlet前后起作用，而拦截器可以深入到方法的前后、异常抛出前后等更深层次的程度作处理（这里也在一定程度上论证了拦截器是利用java的反射机制实现的），所以在Spring框架中，优先使用拦截器； Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-01-01 00:18:35 "},"doc/springboot_starter.html":{"url":"doc/springboot_starter.html","title":"SpringBoot启动&starter","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 SpringBoot 启动原理 @SpringBootApplication 注解 初始化SpringApplication类 SpringApplication类的run方法 @EnableAutoConfiguration ImportSelector ImportSelector 的 selectImports 方法 执行调用栈 & SpringFactoriesLoader starter SpringBoot starter机制 自定义starter SpringBoot 启动原理 @SpringBootApplication @MapperScan(\"com.example.demo.repository\") @EnableScheduling public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } @SpringBootApplication 注解 @SpringBootApplication @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { @SpringBootConfiguration @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Configuration public @interface SpringBootConfiguration { } @EnableAutoConfiguration @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { mybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。 初始化SpringApplication类 加载所有META-INF/spring.factories中的Initializer 加载所有META-INF/spring.factories中的Listener private void initialize(Object[] sources) { if (sources != null && sources.length > 0) { this.sources.addAll(Arrays.asList(sources)); } // 根据标志类javax.servlet.Servlet,org.springframework.web.context.ConfigurableWebApplicationContext是否存在，判断是否是web环境 this.webEnvironment = deduceWebEnvironment(); // 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationContextInitializer，并实例化 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories中的ApplicationListener，并实例化 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 获取执行当前main方法的类，也就是启动类 this.mainApplicationClass = deduceMainApplicationClass(); } SpringApplication类的run方法 public ConfigurableApplicationContext run(String... args) { // 启动任务执行的时间监听器 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; // 设置系统java.awt.headless属性，确定是否开启headless模式(默认开启headless模式) configureHeadlessProperty(); // 通过SpringFactoriesLoader，获取到所有META-INF/spring.factories下的SpringApplicationRunListeners并实例化 SpringApplicationRunListeners listeners = getRunListeners(args); // 开始广播启动 listeners.started(); try { // 创建SpringBoot默认启动参数对象 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 根据启动参数创建并配置Environment(所有有效的配置，如Profile)，并遍历所有的listeners，广播启动环境已准备 ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments); // 打印启动图案 Banner printedBanner = printBanner(environment); // 根据标志类(上面有提到过)，创建对应类型的ApplicationContext context = createApplicationContext(); // 创建异常解析器(当启动失败时，由此解析器处理失败结果) analyzers = new FailureAnalyzers(context); // 准备Spring上下文环境 // 在这个方法中，主要完成了以下几件事： // 1、设置SpringBoot的环境配置(Environment) // 2、注册Spring Bean名称的序列化器BeanNameGenerator，并设置资源加载器ResourceLoader // 3、加载ApplicationContextInitializer初始化器，并进行初始化 // 4、统一将上面的Environment、BeanNameGenerator、ResourceLoader使用默认的Bean注册器进行注册 prepareContext(context, environment, listeners, applicationArguments,printedBanner); // 注册一个关闭Spring容器的钩子 refreshContext(context); // 获取当前所有ApplicationRunner和CommandLineRunner接口的实现类，执行其run方法 // ApplicationRunner和CommandLineRunner功能基本一样，在Spring容器启动完成时执行，唯一不同的是ApplicationRunner的run方法入参是ApplicationArguments，而CommandLineRunner是String数组 afterRefresh(context, applicationArguments); // 通知所有listener，Spring容器启动完成 listeners.finished(context, null); // 停止时间监听器 stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { // 启动有异常时，调用异常解析器解析异常信息，根据异常级别，判断是否退出Spring容器 handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } } 首先遍历执行所有通过SpringFactoriesLoader，在当前classpath下的META-INF/spring.factories中查找所有可用的SpringApplicationRunListeners并实例化。调用它们的starting()方法，通知这些监听器SpringBoot应用启动。 创建并配置当前SpringBoot应用将要使用的Environment，包括当前有效的PropertySource以及Profile。 遍历调用所有的SpringApplicationRunListeners的environmentPrepared()的方法，通知这些监听器SpringBoot应用的Environment已经完成初始化。 打印SpringBoot应用的banner，SpringApplication的showBanner属性为true时，如果classpath下存在banner.txt文件，则打印其内容，否则打印默认banner。 根据启动时设置的applicationContextClass和在initialize方法设置的webEnvironment，创建对应的applicationContext。 创建异常解析器，用在启动中发生异常的时候进行异常处理(包括记录日志、释放资源等)。 设置SpringBoot的Environment，注册Spring Bean名称的序列化器BeanNameGenerator，并设置资源加载器ResourceLoader，通过SpringFactoriesLoader加载ApplicationContextInitializer初始化器，调用initialize方法，对创建的ApplicationContext进一步初始化。 调用所有的SpringApplicationRunListeners的contextPrepared方法，通知这些Listener当前ApplicationContext已经创建完毕。 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。 调用所有的SpringApplicationRunListener的contextLoaded方法，加载准备完毕的ApplicationContext。 调用refreshContext，注册一个关闭Spring容器的钩子ShutdownHook，当程序在停止的时候释放资源（包括：销毁Bean，关闭SpringBean的创建工厂等） 注： 钩子可以在以下几种场景中被调用： 1）程序正常退出 2）使用System.exit() 3）终端使用Ctrl+C触发的中断 4）系统关闭 5）使用Kill pid命令杀死进程 获取当前所有ApplicationRunner和CommandLineRunner接口的实现类，执行其run方法 遍历所有的SpringApplicationRunListener的finished()方法，完成SpringBoot的启动。 @EnableAutoConfiguration EnableAutoConfiguration是一个组合注解，用Import把AutoConfigurationImportSelector导入容器中，SpringBoot启动的时候会加载所有的selector并执行selectImports方法，这个方法会加载META-INF/spring.factories中配置的EnableAutoConfiguration，从而实现加载自动配置 @EnableAutoConfiguration @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { AutoConfigurationPackage：内部是采用了@Import，来给容器导入一个Registrar组件 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Import(AutoConfigurationPackages.Registrar.class) public @interface AutoConfigurationPackage { } @AutoConfigurationImportSelector public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { AutoConfigurationImportSelector实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件) ImportSelector 在使用@Import注解来注册bean的时候，Import注解的值可以是ImportSelector或者DeferredImportSelector的实现类，spring容器会实例化这个实现类，并执行其selectImports方法 spring refresh 12 个方法中的invokeBeanFactoryPostProcessors(beanFactory);会执行ConfigurationClassPostProcessor的processConfigBeanDefinitions方法 @Configguration对@ImportResource、@Bean等注解处理之后，会走到selectImports方法处理 ImportSelector 的 selectImports 方法 其中List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); /** * Return the auto-configuration class names that should be considered. By default * this method will load candidates using {@link SpringFactoriesLoader} with * {@link #getSpringFactoriesLoaderFactoryClass()}. * @param metadata the source metadata * @param attributes the {@link #getAttributes(AnnotationMetadata) annotation * attributes} * @return a list of candidate configurations */ protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } 使用SpringFactoryLoader，读取META-INF/spring.factories文件里所配置的EnableAutoConfiguration。经过exclude和filter等操作，最终确定要装配的类 /** * Load the fully qualified class names of factory implementations of the * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given * class loader. * @param factoryClass the interface or abstract class representing the factory * @param classLoader the ClassLoader to use for loading resources; can be * {@code null} to use the default * @see #loadFactories * @throws IllegalArgumentException if an error occurs while loading factory names */ public static List loadFactoryNames(Class factoryClass, @Nullable ClassLoader classLoader) { String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); } private static Map> loadSpringFactories(@Nullable ClassLoader classLoader) { MultiValueMap result = cache.get(classLoader); if (result != null) { return result; } try { Enumeration urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap<>(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry entry : properties.entrySet()) { List factoryClassNames = Arrays.asList( StringUtils.commaDelimitedListToStringArray((String) entry.getValue())); result.addAll((String) entry.getKey(), factoryClassNames); } } cache.put(classLoader, result); return result; } catch (IOException ex) { throw new IllegalArgumentException(\"Unable to load factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); } } 执行调用栈 & SpringFactoriesLoader selectImports(AnnotationMetadata):79, EnableAutoConfigurationImportSelector (org.springframework.boot.autoconfigure), EnableAutoConfigurationImportSelector.java processDeferredImportSelectors():474, ConfigurationClassParser (org.springframework.context.annotation), ConfigurationClassParser.java parse(Set):184, ConfigurationClassParser (org.springframework.context.annotation), ConfigurationClassParser.java processConfigBeanDefinitions(BeanDefinitionRegistry):308, ConfigurationClassPostProcessor (org.springframework.context.annotation), ConfigurationClassPostProcessor.java postProcessBeanDefinitionRegistry(BeanDefinitionRegistry):228, ConfigurationClassPostProcessor (org.springframework.context.annotation), ConfigurationClassPostProcessor.java invokeBeanDefinitionRegistryPostProcessors(Collection, BeanDefinitionRegistry):270, PostProcessorRegistrationDelegate (org.springframework.context.support), PostProcessorRegistrationDelegate.java invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List):93, PostProcessorRegistrationDelegate (org.springframework.context.support), PostProcessorRegistrationDelegate.java invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory):686, AbstractApplicationContext (org.springframework.context.support), AbstractApplicationContext.java refresh():524, AbstractApplicationContext (org.springframework.context.support), AbstractApplicationContext.java refresh():122, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded), EmbeddedWebApplicationContext.java refresh(ApplicationContext):761, SpringApplication (org.springframework.boot), SpringApplication.java refreshContext(ConfigurableApplicationContext):371, SpringApplication (org.springframework.boot), SpringApplication.java run(String[]):315, SpringApplication (org.springframework.boot), SpringApplication.java run(Object[], String[]):1186, SpringApplication (org.springframework.boot), SpringApplication.java run(Object, String[]):1175, SpringApplication (org.springframework.boot), SpringApplication.java main(String[]):32, DruidManagerApplication (com.pinduoduo.bigdata.druid.manager.api), DruidManagerApplication.java Spring应用启动过程中会执行ConfigurationClassPostProcessor,在使用ConfigurationClassParser分析配置类时，如果发现注解中存在@Import(ImportSelector)的情况，就会创建一个相应的ImportSelector对象， 并调用其方法public String[] selectImports(AnnotationMetadata annotationMetadata)。 使用SpringFactoriesLoader从META-INF/spring.factories提取要加载的Bean Spring的SpringFactoriesLoader工厂的加载机制类似java提供的SPI机制一样，是Spring提供的一种加载方式。只需要在classpath路径下新建一个文件META-INF/spring.factories，并在里面按照properties格式填写好接口和实现类即可通过SpringFactoriesLoader来实例化相应的Bean。其中key可以是接口、注解、或者抽象类的全名。value为相应的实现类，当存在多个实现类时，用\",\"进行分割。 starter SpringBoot将所有的常见开发功能，分成了一个个场景启动器（starter），这样我们需要开发什么功能，就导入什么场景启动器依赖即可，eg： 需要开发web的功能，那么引入spring-boot-starter-web 需要开发模板页的功能，那么引入spring-boot-starter-thymeleaf 需要整合redis，那么引入spring-boot-starter-data-redis 需要整合amqp，实现异步消息通信机制，那么引入spring-boot-starter-amqp SpringBoot starter机制 SpringBoot中的starter能够抛弃以前繁杂的配置，将其统一集成进starter，应用者只需要在maven中引入starter依赖，SpringBoot就能自动扫描到要加载的信息并启动相应的默认配置。starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。SpringBoot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。SpringBoot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循\"约定大于配置\"的理念。 自定义starter /META-INF/spring.factories #-------starter自动装配--------- org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.demo.starter.config.DemoConfig DemoConfig // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package com.demo.starter.config; import com.demo.starter.properties.DemoProperties; import com.demo.starter.service.DemoService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @EnableConfigurationProperties({DemoProperties.class}) @ConditionalOnProperty( prefix = \"demo\", name = {\"isopen\"}, havingValue = \"true\" ) public class DemoConfig { @Autowired private DemoProperties demoProperties; public DemoConfig() { } @Bean( name = {\"demo\"} ) public DemoService demoService() { return new DemoService(this.demoProperties.getSayWhat(), this.demoProperties.getToWho()); } } 引用并测试 // 引入自定义的starter compile files('src/libs/demo-spring-boot-starter-0.0.1-RELEASE.jar') 使用&测试 @RestController public class DemoControl { @Resource(name = \"demo\") private DemoService demoService; @GetMapping(\"/say\") public String sayWhat() { return demoService.say(); } } Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2022-05-28 23:16:24 "},"doc/bean/design.html":{"url":"doc/bean/design.html","title":"7.1 Spring中的设计模式","keywords":"","body":"Spring中用到了哪些设计模式？ 工厂模式: beanFactory, FactoryBean 单例模式: getSingleton方法 适配器模式: SpringMvc中的HandlerAdapter，根据Handler规则执行不同的Handler 装饰器模式: 各种 Wrapper， Decorator 代理模式: jdk动态代理，cglib动态代理 观察者模式: ApplicationEvent, ApplicationListener 策略模式: Resource 接口 模版方法: 父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-30 09:21:23 "},"doc/pro.html":{"url":"doc/pro.html","title":"7.2 Spring中常见问题","keywords":"","body":"问题 如何改变bean注入顺序；如何确保某个bean先实例化出来？ BeanFactoryPostProcessor Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-04-24 12:00:26 "},"doc/other/words.html":{"url":"doc/other/words.html","title":"8.1 单词","keywords":"","body":"单词 assemble v. 聚集; 集合; 收集; 装配; 组装; boilerplate n. (可供模仿的) 样板文件，文件范例; circular adj. 圆形的; 环形的; 圆的; 环行的; 绕圈的; 循环论证的(以一种观点证明另一观点，接着再用后一种观点反过来去证明前一观点); n. (同时送达很多人的)印刷信函(或通知、广告) ; customize vt. 定做，定制，按客户具体要求制造； Conceptual adj. 概念上的，观念上的 convey v. 表达，传递(思想、感情等); 传送; 运送; 输送; explicit adj. 清楚明白的; 易于理解的; (说话) 清晰的，明确的; 直言的; 坦率的; 直截了当的; 不隐晦的; 不含糊的; imperative adj. 必要的，不可避免的；紧急的；命令的，专横的；势在必行的；[语]祈使的 n. 必要的事；命令；需要；规则；[语]祈使语气 instantiate v. 例示；用具体例子说明; instantiation n. 实例化；[计] 例示 interdependency n. 互相依赖；相关性; invasive adj. 侵入的；入侵性的；扩散的 nested v. 筑巢; 巢居; 嵌套(信息); plug n. 插头；塞子；栓； vi. 塞住；用插头将与电源接通； vt. 插入；塞住；接插头 pluggability 可插性 propagation n. 传播; 扩展; 宣传; 培养; recipe n. 烹饪法; 食谱; 方法; 秘诀; 诀窍; scenario n. 设想; 方案; 预测; (电影或戏剧的) 剧情梗概; unresolvable 不能解决的 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-09 23:10:37 "}}