{"./":{"url":"./","title":"Introduction","keywords":"","body":"spring 源码阅读笔记 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "},"doc/preface/":{"url":"doc/preface/","title":"1 前言","keywords":"","body":"学习目标 熟悉Spring原理 对各种Spring面试题能从容对答 借此熟悉各种设计模式，巩固各种Java基础知识 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "},"doc/bean/":{"url":"doc/bean/","title":"2 Ioc&Bean","keywords":"","body":"Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "},"doc/bean/ioc_bean.html":{"url":"doc/bean/ioc_bean.html","title":"2.1 Ioc & Bean概念","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Ioc 容器 & Bean Spring处理流程 Ioc Container Bean Ioc 容器 & Bean Spring处理流程 附：spring docs Ioc Container The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects. ApplicationContext这个接口就代表IoC容器，它负责实例化、配置和组装bean。容器通过读取配置文件的元数据来获取要实例化、配置和组装哪些对象的指令。配置文件支持xml,Java注解和纯Java代码。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。 Bean In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container. 在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是一个由Spring IoC容器实例化、组装和管理的对象。 Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata: 在容器内部，这些bean定义表示为BeanDefinition对象，包含着以下元数据： A package-qualified class name: typically, the actual implementation class of the bean being defined.（全限定类名） Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).（Bean的行为配置元素，作用域，生命周期回调等） References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.（对该bean执行其工作所需的其它bean的引用。） Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.（在创建bean对象时的其他配置，如连接池的最大数量） Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 10:02:10 "},"doc/bean/BeanFactory.html":{"url":"doc/bean/BeanFactory.html","title":"2.1 BeanFactory接口","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 BeanFactory 定义和类图 BeanFactory 定义和类图 spring docs of BeanFactory The root interface for accessing a Spring bean container. 访问Spring容器的最顶层的interface This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. \"request\" and \"session\" scopes in a web environment). BeanFactory的实现类即具体的容器，拥有一系列bean的定义，并实现这些基础方法，能返回bean的对象实例 The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of \"Expert One-on-One J2EE Design and Development\" for a discussion of the benefits of this approach. BeanFactory是应用程序组件的注册器，统一管理 Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection). BeanFactory负责加载bean,并能返回Java对象实例，并最好能支持Bean之间的引用关系 Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. BeanFactory要尽可能的实现Bean的生命周期接口 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "},"doc/bean/ConfigurableListableBeanFactory.html":{"url":"doc/bean/ConfigurableListableBeanFactory.html","title":"2.2 testClassPathXmlApplicationContextBean源码走读","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 ConfigurableListableBeanFactory & bean创建 接口定义和类图 ListableBeanFactory ConfigurableBeanFactory AutowireCapableBeanFactory 测试代码流程 ConfigurableListableBeanFactory & bean创建 接口定义和类图 /** * Configuration interface to be implemented by most listable bean factories. * In addition to {@link ConfigurableBeanFactory}, it provides facilities to * analyze and modify bean definitions, and to pre-instantiate singletons. * * This subinterface of {@link org.springframework.beans.factory.BeanFactory} * is not meant to be used in normal application code: Stick to * {@link org.springframework.beans.factory.BeanFactory} or * {@link org.springframework.beans.factory.ListableBeanFactory} for typical * use cases. This interface is just meant to allow for framework-internal * plug'n'play even when needing access to bean factory configuration methods. * * @author Juergen Hoeller * @since 03.11.2003 * @see org.springframework.context.support.AbstractApplicationContext#getBeanFactory() */ public interface ConfigurableListableBeanFactory extends ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory { ListableBeanFactory public interface ListableBeanFactory extends BeanFactory Extension of the BeanFactory interface to be implemented by bean factories that can enumerate（v. 列举; 枚举;）all their bean instances, rather than attempting bean lookup by name one by one as requested by clients. BeanFactory implementations that preload all their bean definitions (such as XML-based factories) may implement this interface. ListableBeanFactory 比 BeanFactory 多了一些方法 containsBeanDefinition(String beanName) Check if this bean factory contains a bean definition with the given name. findAnnotationOnBean(String beanName, Class annotationType) Find an Annotation of annotationType on the specified bean, traversing its interfaces and super classes if no annotation can be found on the given class itself, as well as checking the bean's factory method (if any). getBeanDefinitionCount() Return the number of beans defined in the factory. getBeanDefinitionNames() Return the names of all beans defined in this factory. getBeanNamesForAnnotation(Class annotationType) Find all names of beans which are annotated with the supplied Annotation type, without creating corresponding bean instances yet. getBeanNamesForType(Class type) Return the names of beans matching the given type (including subclasses), judging from either bean definitions or the value of getObjectType in the case of FactoryBeans. getBeanNamesForType(Class type, boolean includeNonSingletons, boolean allowEagerInit) Return the names of beans matching the given type (including subclasses), judging from either bean definitions or the value of getObjectType in the case of FactoryBeans. getBeanNamesForType(ResolvableType type) Return the names of beans matching the given type (including subclasses), judging from either bean definitions or the value of getObjectType in the case of FactoryBeans. getBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) Return the names of beans matching the given type (including subclasses), judging from either bean definitions or the value of getObjectType in the case of FactoryBeans. getBeansOfType(Class type) Return the bean instances that match the given object type (including subclasses), judging from either bean definitions or the value of getObjectType in the case of FactoryBeans. getBeansOfType(Class type, boolean includeNonSingletons, boolean allowEagerInit) Return the bean instances that match the given object type (including subclasses), judging from either bean definitions or the value of getObjectType in the case of FactoryBeans. getBeansWithAnnotation(Class annotationType) Find all beans which are annotated with the supplied Annotation type, returning a Map of bean names with corresponding bean instances. ConfigurableBeanFactory public interface ConfigurableBeanFactory extends HierarchicalBeanFactory, SingletonBeanRegistry 同时继承了HierarchicalBeanFactory 和 SingletonBeanRegistry 这两个接口，即同时继承了分层和单例类注册的功能 AutowireCapableBeanFactory 测试代码流程 @Test public void testClassPathXmlApplicationContextBean() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); User user = (User) applicationContext.getBean(\"user\"); Assert.assertTrue(user != null); Assert.assertTrue(user.getTestStr().equals(\"testStr\")); } 附ClassPathXmlApplicationContext类的UML ClassPathXmlApplicationContext构造函数执行 public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); // 设置`this.configLocations` setConfigLocations(configLocations); if (refresh) { // 这里refresh为true（重点方法） // 这里使用了父类`AbstractApplicationContext`的`refresh`方法 refresh(); } } AbstractApplicationContext的refresh方法 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // 内部的 BeanFactory // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); // 先看try里面做了哪些事情(读别的源码也一样，先主后次) try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 构造生成ConfigurableListableBeanFactory类型的BeanFactory(具体是DefaultListableBeanFactory) 调用了抽象类AbstractRefreshableApplicationContext的refreshBeanFactory方法 @Override protected final void refreshBeanFactory() throws BeansException { // 如果BeanFactory不为空，则清除BeanFactory里面的实例，并销毁BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // BeanFactory的实例工厂：DefaultListableBeanFactory DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); // 设置是否可以同名覆盖，循环依赖 customizeBeanFactory(beanFactory); // 解析比如xml文件，并把xml文件中的标签封装成BeanDefinition对象，加载到工厂中, 通常是通过代理读取器实现 // 比如 通过 XmlBeanDefinitionReader 读取 ClassPathXmlApplicationContext中传入的 configResources xml【模板设计】 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); } } BeanFactory实例工厂完成解析xml文件中的Bean并封装成BeanDefinition加载到工厂中 抽象类AbstractXmlApplicationContext的loadBeanDefinitions方法 DefaultListableBeanFactory存储了BeanDefinition /** Map of bean definition objects, keyed by bean name. */ private final Map beanDefinitionMap = new ConcurrentHashMap<>(256); 附DefaultListableBeanFactoryUML（DefaultListableBeanFactory就是一个独立的Ioc容器） 有了beanFactory,要使用之，还要做各种工作，回到refresh方法 prepareBeanFactory /** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */ protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 设置类加载器（要实例化bean,就需要类加载器） // Tell the internal bean factory to use the context's class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); // 设置EL表达式解析器（Bean初始化完成后填充属性时会用到） beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // 设置属性注册解析器PropertyEditor beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // 注册各种系统环境的bean组件（environment，systemProperties，systemEnvironment） // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); } } postProcessBeanFactory(beanFactory初始化后的一些定制化处理) 在所有的beanDenifition加载完成之后，bean实例化之前执行 /** * Modify the application context's internal bean factory after its standard * initialization. All bean definitions will have been loaded, but no beans * will have been instantiated yet. This allows for registering special * BeanPostProcessors etc in certain ApplicationContext implementations. * @param beanFactory the bean factory used by the application context */ protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { } // TODO 测试 invokeBeanFactoryPostProcessors(beanFactory) /** * Instantiate and invoke all registered BeanFactoryPostProcessor beans, * respecting explicit order if given. * Must be called before singleton instantiation. */ protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { // 1.getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值 // 2.invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } registerBeanPostProcessors(beanFactory) /** * Instantiate and invoke all registered BeanPostProcessor beans, * respecting explicit order if given. * Must be called before any instantiation of application beans. */ protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this); } initMessageSource & initApplicationEventMulticaster // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); 消息处理 & 事件监听 Initialize other special beans in specific context subclasses. onRefresh() /** * Template method which can be overridden to add context-specific refresh work. * Called on initialization of special beans, before instantiation of singletons. * This implementation is empty. * @throws BeansException in case of errors * @see #refresh() */ protected void onRefresh() throws BeansException { // For subclasses: do nothing by default. } Check for listener beans and register them. registerListeners() /** * Add beans that implement ApplicationListener as listeners. * Doesn't affect other listeners, which can be added without being beans. */ protected void registerListeners() { // 注册特殊的监听器 // Register statically specified listeners first. for (ApplicationListener listener : getApplicationListeners()) { getApplicationEventMulticaster().addApplicationListener(listener); } // 取到所有监听器的名称，设置到上文初始化的广播器 // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) { getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); } // 如果存在早期应用事件，发布 // Publish early application events now that we finally have a multicaster... Set earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (earlyEventsToProcess != null) { for (ApplicationEvent earlyEvent : earlyEventsToProcess) { getApplicationEventMulticaster().multicastEvent(earlyEvent); } } } Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory) 创建所有非懒加载的单例类（并invoke BeanPostProcessors） publish corresponding event.finishRefresh() /** * Finish the refresh of this context, invoking the LifecycleProcessor's * onRefresh() method and publishing the * {@link org.springframework.context.event.ContextRefreshedEvent}. */ protected void finishRefresh() { // Clear context-level resource caches (such as ASM metadata from scanning). clearResourceCaches(); // Initialize lifecycle processor for this context. initLifecycleProcessor(); // Propagate refresh to lifecycle processor first. getLifecycleProcessor().onRefresh(); // Publish the final event. publishEvent(new ContextRefreshedEvent(this)); // Participate in LiveBeansView MBean, if active. LiveBeansView.registerApplicationContext(this); } User user = (User) applicationContext.getBean(\"user\"); AbstractBeanFactory的doGetBean方法 protected T doGetBean(final String name, @Nullable final Class requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "},"doc/bean/questions.html":{"url":"doc/bean/questions.html","title":"2.3 常见面试题","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 常见面试题 bean的生命周期？ 常见面试题 bean的生命周期？ Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "},"doc/other/words.html":{"url":"doc/other/words.html","title":"3.1 单词","keywords":"","body":"单词 assemble v. 聚集; 集合; 收集; 装配; 组装; boilerplate n. (可供模仿的) 样板文件，文件范例; convey v. 表达，传递(思想、感情等); 传送; 运送; 输送; explicit adj. 清楚明白的; 易于理解的; (说话) 清晰的，明确的; 直言的; 坦率的; 直截了当的; 不隐晦的; 不含糊的; instantiate v. 例示；用具体例子说明; interdependency n. 互相依赖；相关性; scenario n. 设想; 方案; 预测; (电影或戏剧的) 剧情梗概; Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-06-18 09:52:42 "}}